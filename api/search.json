[{"id":"857b99bbc17d9cdd5bc19bc9d8890bad","title":"计算机网络学习笔记","content":"第一章 概述1.1 网络、互联网和因特网网络：网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。\n互联网：多个网络通过路由器互连起来，构成了一个覆盖范围更大的网络，即互联网（互连网）。因此，互联网又称为“网络的网络（Network of Networks）”。\n因特网：因特网（Internet）是世界上最大的互连网络。\n三个阶段：\n\nTCP/IP协议成为ARPANET的标准协议\n建成三级结构的因特网NSFNET（主干网、地区网、校园网）\n形成多层次ISP结构的互联网 ISP：互联网服务提供商\n\n用户通过因特网服务提供者ISP（Internet Service Provider）接入因特网：ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从ISP得到所需要的IP地址。\n1.2 因特网的组成边缘部分：主机（端系统），为用户所用，用于通信和资源共享\n核心部分：大量网络和路由器组成，为边缘部分提供服务\n\n路由器：实现分组交换的核心部件\n报文：发送的整块数据\n存储转发：接收-暂存-查找-转发\n\n\n\n\n\n1.3 三种交换方式电路交换（Circuit Switching）：建立连接-通话-释放连接。独占物理通路，传输效率低。\n报文交换（Message Switching）：整个报文传送到相邻节点，存储转发。\n分组交换（Packet Switching）：将报文划分成数据段再加上首部分后分组发送。路由器是实现的关键构件。\n\n\n\n\n1.4 计算机网络的定义和分类简单定义：一些互相连接的、自治的计算机的集合。\n较好定义：计算机网络主要是由一些通用的，可编程的硬件（一定包含有中央处理机CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。\n分类：\n\n\n\n\n1.5 计算机网络的性能指标\n速率：\n数据的传输速率，也称数据率(data rate)或比特率(bit rate)\n\n带宽：\n网络中通道传送数据的能力，也称“最高数据率”，单位bit/s\n\n吞吐量：\n单位时间内通过某个网络（或信道、接口等）的实际数据量，受网络的带宽或额定速率的限制（≤额定速率和带宽）\n\n时延：\n数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间\n发送时延 = 数据帧长度(bit)/发送速率(bps)\n传播时延 = 信道长度/电磁波传播速率\n总时延 = 发送时延+传播时延+处理时延+排队时延  (注意区分发送时延与传播时延)\n\n时延带宽积：\n时延带宽积 = 传播时延 * 带宽，单位bit，表示链路可容纳多少个比特\n\n**往返时间RTT(Round-Trip Time)**：\n从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间(即双向交互一次所需的时间)\n发送时间 = 数据长度/发送速率 \n有效数据率 = 数据长度/(发送时间+RTT)\n\n利用率：\n分为信道利用率和网络利用率两种\n\n丢包率(教材已无)：\n在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率(又叫分组丢失率)\n\n\n**计算机网络的非性能指标(了解)**：费用、质量、标准化、可靠性、可扩展升级性、易于管理和维护\n1.6 计算机网络的体系结构历史：\n\n\nTCP/IP四层协议：\n\n应用层：任务是通过应用进程间的交互完成特定的网络应用，定义的是应用进程间通信和交互的规则，教务的数据单元称为**报文(message)**，(协议HTTP、SMTP、DNS等)\n运输层：任务是向两台主机中进程间的通信提供通用的数据传输服务（TCP、UDP）\n网际层（网络层）：负责为分组交换上的不同主机提供通信服务（IP）\n网络接口层（数据链路层和物理层）：数据链路层负责两个相邻节点之间传送数据，物理层传输数据单位为比特\n\n术语：\n\n实体：任何可发送和接收信息的硬件或软件进程。\n\n协议(水平的)：控制对等实体(或多个实体)通信的规则的集合。（三要素：语法、语义、同步）\n\n服务(垂直的)：在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务（通过服务原语OSI）\n\n服务访问点：相邻两层的实体交换信息的接口\n\n协议数据单元(PDU)：对等层次之间传送的数据单位（Protocol Data Unit）\n\n服务数据单元(SDU)：同一系统内，层与层之间交换的数据单位（Service Data Unit）\n\n\n\n\n第二章 物理层2.1 基本概念\n物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体\n为数据链路层屏蔽了各种传输媒体的差异，使数据链路层不必考虑网络具体的传输媒体是什么\n\n2.2 物理层下的传输媒体(了解)\n传输媒体也称为传输介质或传输媒介，是数据传输系统中在发送器和接收器之间的物理通路\n传输媒体分为两类，即导引型传输媒体(电磁波沿固体媒体传播，如同轴电缆、光纤等)和非导引型传输媒体(电磁波自由传输，无线传输，频段广，时延大，如无线电波、红外线、可见光等)\n传输媒体不属于计算机网络体系结构的任何一层，位于物理层之下\n\n2.3 传输方式\n串行传输与并行传输\n在传输线路上的传输采用是串行传输，计算机内部的数据传输常用并行传输)\n\n同步传输与异步传输\n\n同步传输：\n以稳定的比特流的形式传输，字节之间没有间隔\n\n\n​        接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1\n\n异步传输：\n字节为独立的传输单位，字节之间的时间间隔不是固定\n字节之间异步，字节中的每个比特仍然同步\n通常在每个字节前后分别加上起始位和结束位\n\n\n\n单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）\n\n单工通信，即只能有一个方向的通信而没有反方向的交互，只需要一条信道\n半双工通信和全双工通信需要两条信道，半双工通信双方不能同时发送/接收消息\n\n\n\n2.4 编码与调制基本术语：\n数据：运送消息的实体\n\n信号：数据的电气或电磁表现，分为模拟信号和数字信号\n\n模拟信号(analogous signal)：代表消息的参数的取值是连续的\n\n数字信号(digital signal)：代表消息的参数的取值是离散的\n\n基带信号(即基本频带信号)：来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号\n\n信道(channel)：向某一个方向传输信息的媒体，电路一般包含发送信道和接收信道\n\n码元(code)：在使用时间域(时域)的波形表示数字信号时，代表不同离散数值的基本波形\n\n调制(modulation)：使基带信号能更好地在信道中传输的过程，分为基带调制(编码coding)和带通调制\n\n编码(基带调制)：仅对基带信号的波形进行变换，不改变其性质\n\n带通调制：使用载波(carrier)进行调制，改变频率范围等(使之转换为模拟信号\n\n\n常用编码方式： \n不归零制：正点平为1，负电平为0\n归零制：正脉冲为1，负脉冲为0\n曼彻斯特编码：位周期中心向下跳变为1，位周期中心向上跳变为0，也可以反过来定义\n差分曼彻斯特编码：每一位中心处始终都有跳变，位开始边界有跳变位0，没有跳变为1\n\n注意：\n\n由于不归零编码存在同步问题，因此计算机网络中的数据传输不采用这类编码\n归零编码虽然自同步，但由于大部分的数据带宽都用来传输“归零”，编码效率低\n差分曼彻斯特编码比曼彻斯特编码变化少，更适合较高的传输速率\n\n基本的带通调制方法：\n\n补充：\n\n除以上方法外，还有将振幅和相位混合调制的正交振幅调制QAM(Quadrature Amplitude Modulation)方法\n由于频率是相位随时间的变化率，所以一次只能调制频率和相位两个中的一个\n\n2.5 信道的极限容量信号在信道上传输时会不可不可避免地产生失真，但接收端如果能从失真的识别出原来的信号，则视为无影响\n码元传输的速率越高、信号传输的距离越远、噪声干扰越大或传输媒体质量越差，在接收端的波形的失真就越严重\n奈氏准则：\n在理想条件下，为了避免码间串扰，码元传输速率是由上限的\n在带宽为W(Hz)的低通信道中，码元传输的最高速率是2W Baud(码元/秒)，W为信道带宽\n在带宽为W(Hz)的带通信道中，码元传输的最高速率是W Baud(码元/秒)\n要提高传输速率(比特率)，必须设法使一个码元能携带更多个比特的信息量，需要采用多元制\n实际信道所能传输的最高码元速率，要明显低于奈氏准则给出的上限数值\n\n信噪比和香农公式：\n信噪比：\n信号平均功率和噪声平均功率的比值，即S/N，单位分贝(dB)\n信噪比(dB) = 10log10(S/N) (dB)\n\n香农公式：\n\n\n2.6 信道复用技术复用：\n将多路信号组合在一条物理信道上进行传输，降低成本，提高信道利用率，在接收端再分离(分用)\n\n需要使用复用器(multiplexer和demultiplexer)，在二者之间就是用户共享的高速信道\n\n\n常用的信道复用技术：\n频分复用 FDM (Frequency Division Multiplexing)：\n所有用户在同样的时间占用不同的带宽资源，这里的“带宽”是频率带宽\n\n时分复用TDM (Time Division Multiplexing)：\n时分复用的所有用户在不同的时间占用同样的频带宽度\n将时间划分为一段段等长的时分复用帧（TDM帧），每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙\n每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的，时分复用可能会造成线路资源的浪费\n\n统计时分复用 STDM (Statistic TDM)\n是改进的时分复用，使用STDM帧来传送数据\nSTDM帧不固定分配时隙，而是按需动态分配时隙，用户占用的时隙不是周期出现\n能提高信道的利用率\n\n波分复用 WDM(Wavelength Division Multiplexing)\n光的频分复用，使用光复用器和分用器在一根光纤上复用多路光载波信号\n\n码分复用 CDM (Code Division Multiplexing)\n当码分复用信道为多个不用地址的用户所共享时，就称为码分多址 CDMA (Code Division Multiple Access)\n用户可以在同样的时间使用同样的频带，由于各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰\n\n\n\n第三章 数据链路层3.1 数据链路层概述相关术语：\n链路(link)：从一个结点到相邻结点的一段物理线路(有线或无线)\n数据链路(data link)：在链路的基础上增加了必要的硬件(如网络适配器)和软件(如协议的实现)\n帧：数据链路层的协议数据单元\n\n注意：\n\n不同的链路层可能采用不同的数据链路层协议\n局域网属于数据链路层，局域网虽然是网络，但并不把局域网放在网络层中讨论。\n\n数据链路层使用的信道：主要是点对点信道和广播信道\n\n\n三个重要问题：封装成帧、差错检测和可靠传输\n\n封装成帧：\n\n网络层的IP数据报传送到数据链路层就成为帧(framing)的数据部分\n\n在帧的数据部分的前后分别添加首部和尾部，就构成了一个完整的帧\n\n首部和尾部的一个重要作用就是进行帧定界\n\n\n\n差错检测：\n传输过程中可能会产生比特差错，即1 可能会变成 0， 而 0 也可能变成 1\n\n可靠传输：\n\n接收方主机收到有误码的帧后，则会丢弃该帧\n如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本\n\n\n\n补充：\n如果是使用广播信道的数据链路层，除了包含上面三个主要问题外，还需要解决确定目的地址和传输时数据碰撞等问题。\n3.2 封装成帧\n\n补充：\n\n转义字符ESC：发送端的数据链路层在数据中出现控制字符SOH(帧首部)或EOT(帧尾部)的前面插入一个转义字符ESC(其十六进制编码是1B)。\n\n接收端的数据链路层在将数据送往网络层之前会删除插入的转义字符。\n\n如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个\n\n以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符\n\n\n3.3 差错检测\n误码率BER(Bit Error Rate)：传输错误的比特占比特总数的比例\n\n奇偶校验(不常用)：\n\n循坏冗余检验CRC(Cyclic Redundancy Check)\n\n\n3.4 可靠传输概念：循坏冗余检验CRC技术只能检测出差错，并不能定位和纠正差错\n若仅使用循坏冗余检验CRC技术，只能做到对单个帧的无差错接受，即帧的“无比特差错”，不能解决“无传输差错”(帧的丢失、重复、失序，又叫分组丢失、分组重复、分组失序)\n\n\n解决传输差错的3种协议：\n停止-等待协议SW(Stop-and-Wait)\n回退N帧协议GBN(Go-Back-N)\n选择重传协议SR(Selective Request)\n\n这3种可靠传输实现机制的基本原理并不仅限于数据链路层，也应用于计算机网络体系结构的各层协议中\n停止-等待协议SW(Stop-and-Wait)：\n\n\n数据分组编号和ACK分组编号分别用来使发送方和接收方判断数据/ACK分组是否重复，都只需要一个比特编号，即0和1\n\n数据链路层一般不会出现ACK分组迟到的情况，因此数据链路层的停止-等待协议SW可以不用给ACK分组编号\n\n停止-等待协议的信道利用率：\n\n\n\nTD：是发送方发送数据分组所耗费的发送时延\nRTT：是收发双方之间的往返时间\nTA：是接收方发送确认分组所耗费的发送时延\nTA一般远小于TD，可忽略，当RTT&gt;&gt;TD时，信道利用率会非常低，这也是停止-等待协议的缺点\n若出现重传，信道利用率还会降低\n\n\n\n回退N帧协议GBN(Go-Back-N)：\n\n\n\n\n\n\n\n\n\n\n在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议\n由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高\n\n选择重传协议SR(Selective Request)：\n\n\n\n\n\n\n\n\n\n\n\n3.5 点对点协议PPP(Point-to-Point Protocol)概念和组成：互联网用户通常需要连接到某个ISP(Internet Service Provider)才能接入互联网，PPP协议就是用户计算机和ISP进行通信时所使用的数据链路协议\n\n\n\n\nPPP协议的帧格式：\n字段意义：\n\n面向字节的异步传输：字节填充法(插入“转义字符”)\n\n面向比特的同步传输：比特填充法(插入“比特0”)\n发送方：发现连续的5个比特1后，填充1个比特0\n接收方：发现连续的5个比特1后，删除1个比特0\n\n\nPPP协议的工作状态：\n\n\n当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接\n\nPC 机向路由器发送一系列的 链路控制协议LCP 分组(封装成多个 PPP 帧)\n\n这些分组及其响应选择一些 PPP 参数，并进行网络层配置，网络控制协议NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。\n\n通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。\n\n\n总结：\nPPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容\n3.6 媒体接入控制(介质访问控制) —— 广播信道背景：共享信道带来的问题：如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(Medium Access Control)\n\n\n\n\n随机接入 —— CSMA/CD协议(总线局域网使用)：\n概念：\n\n\n\n\n\n\n工作流程：\n\n\n\n争用期(contention period)/碰撞窗口(collision window)：\n\n\n​        显然，在使用CSMA/CD协议时，一个站点不可能同时进行发送和接收，因此不可能进行全双工通信，而只能        \n​        进行双向交替通信(半双工通信)\n\n最小和最大帧长\n\n\n​        最大帧长：数据部分一般上限为1500字节\n\n截断二进制指数退避算法(truncated binary exponential backoff)\n\n\n​        \n\nCSMA/CD 协议的信道利用率：\n\n\n\n局限：\n\n每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率\n\nCSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CS协议\n\n\n\n\n随机接入 —— CSMA/CA协议(无线局域网使用)：\n概念：\nCSMA/CA —— 载波监听多址接入/碰撞避免(Carrier Sense Multiple Access/Collision Avoidance)\n\n\n\n帧间间隔IFS(InterFrame Space)\n\n\n\n工作原理：\n\n\n\n源站在检测到信道空闲后还要再等待一段时间DIFS：可能有其他的站有高优先级的帧要发送。若有，就要让 高优先级帧先发送\n目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧：SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式\n信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道：防止多个站点同时发送数据而产生碰撞\n\n\nCSMA/CA协议退避算法：\n\n使用时机\n\n使用示例\n\n\n\n\n\n\n信道预约和虚拟载波监听：\n\n\n\n\n\n\n3.7 MAC地址、IP地址以及ARP协议3.7.1 MAC地址MAC地址概念：\n又称为硬件地址或物理地址，但不属于物理层范畴，而是属于数据链路层范畴\n使用点对点信道的数据链路层不需要引入地址\n使用广播信道的数据链路层必须使用地址来唯一标识各主机，即使用一个数据链路层地址，由于这类地址是用于媒体接入控制MAC(Media Access Control)，因此被称为MAC地址\n一般情况下，每个网路适配器有唯一的MAC地址，而交换机和路由器往往有更多的网络接口，所以有更多的MAC地址。所以严格来说，MAC地址是对网络上各接口的唯一标识，而不是对各设备的唯一标识。\n\n无效MAC帧：\n数据字段的长度与长度字段的值不一致\n\n帧的长度不是整数个字节\n\n用收到的帧检验序列 FCS 查出有差错\n\n数据字段的长度不在 46 ~ 1500 字节之间(首部和尾部共18字节，因此有效的 MAC 帧长度为 64 ~ 1518 字节之间)\n\n\n注意：对于检查出的无效MAC帧就简单地丢弃，以太网不负责重传丢弃的帧。\n单播MAC地址：主机B给主机C发送单播帧，主机B首先要构建该单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该单播帧，主机C的网卡发现该单播帧的目的MAC地址与自己的MAC地址匹配，接受该帧并将该帧交给其上层处理\n广播MAC地址：假设主机B要发送一个广播帧，主机B首先要构建该广播帧，在帧首部中的目的地址字段填入广播地址，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该广播帧。主机A和C都会收到该广播帧，发现该帧首部中的目的地址字段的内容是广播地址，就知道该帧是广播帧，主机A和主机C都接受该帧，并将该帧交给上层处理\n3.7.2 IP地址IP地址概念：\n\n数据包转发过程中IP地址与MAC地址的变化情况\n\n\n\n3.7.3 地址解析协议ARP应用：从IP地址找出其对应的MAC地址\n工作原理和流程：\n\n补充：\n通过ARP协议获取的MAC地址为动态类型，声明周期默认为2分钟，这是因为IP地址与MAC地址的对应关系并不是永久性的，MAC地址可能会改变(如改变网卡后)\nARP协议只能在一段链路或一个网络上使用，而不能跨网络使用\n\n3.8 集线器与交换机区别集线器：概述：\n\n传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线\n采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)\n集线器的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行\n集线器在物理层扩展以太网(工作在物理层)，将多个以太网段连成更大的、多级星形结构的以太网\n使用集线器互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到总线上的其他各个主机\n\n优点：\n\n使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信\n扩大了以太网覆盖的地理范围(扩大了广播域)\n\n缺点：\n\n碰撞域增大了，但总的吞吐量并未提高\n如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来\n\n补充：\n\n碰撞域（collision domain）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络\n碰撞域越大，发生碰撞的概率越高\n广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。\n\n交换机：网桥：\n\n网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发和过滤\n\n当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。\n\n\n交换机：\n\n以太网交换机(switch)实质上就是一个多接口的网桥\n\n使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，而不是网络中的其他各个主机(前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了)\n\n\n总结：\n集线器是在物理层上实现以太网的扩展，而交换机是在数据链路层上\n\n使用集线器，扩大了碰撞域/冲突域，而使用交换机能隔离碰撞域/冲突域，性能远远超过工作在物理层的集线器，这就使得集线器逐渐被市场淘汰\n\n\n3.9 以太网交换机自学习和转发帧的流程\n\n\n\n\n\n3.10 以太网交换机的生成树协议STP(Spanning Tree Protocol)\n\n\n\n\n\n3.11 虚拟局域网VLAN(Virtual Local Area Network)概念：\n由一些局域网网段构成的与物理位置无关的逻辑组，而这些逻辑组具有某些共同的需求\n每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN\n\n特点：\n同一个VLAN内部可以广播通信，不同VLAN不可以广播通信，有效避免了广播风暴\n\n虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。\n\n由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。\n\n\n实现机制：\n未整理\n\n","slug":"计算机网络学习笔记","date":"2023-07-11T07:17:04.000Z","categories_index":"","tags_index":"计算机网络","author_index":"Qin Zehao"},{"id":"61cb2404786c8e041ac91f953c81aea7","title":"Linux下Redis的使用","content":"CentOS 7虚拟机下Redis的启动和使用常用命令如下（使用这些命令前要先配置系统服务文件）：\n\n启动Redis： –  systemctl start redis\n查看Redis运行状态： –  systemctl status redis  或 –  ps -ef | grep redis\n停止Redis： –  systemctl stop redis\n设置开机自启： –  systemctl enable redis\n使用Redis命令行客户端： –  redis-cli -a password\n退出Redis命令行客户端： –  stop/quit/Ctrl + D\n\n使用Redis图形化客户端：\ngithub地址：https://github.com/uglide/RedisDesktopManager\n安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\n打开图形化客户端（RESP）的连接，设置相应的连接名，输入IP地址和Rdis密码后即可使用\n查看CentOS 7虚拟机IP的命令： –  ifconfig\n\n","slug":"Linux下Redis的使用","date":"2023-07-09T09:35:15.000Z","categories_index":"","tags_index":"study note","author_index":"Qin Zehao"},{"id":"3405a51be28fbdb1c58ecac6d40a5d4d","title":"LRU缓存算法","content":"LRU缓存\n最近在做6.830 Lab2时涉及到了实现BufferPool中的eviction policy，即页面置换算法，简单来说，PageId与Page的映射关系为HashMap&lt;PageId, LinkedNode&gt; bufferPool，LinkedNode是自定义双向链表节点，节点内保存了PageId和Page，以及前驱和后继节点prev、next。每当BufferPool中的Page被访问时，将该PageId对应的LinkedNode移动到链表的头部。同时当有Page需要放置到BufferPool中，且BufferPool的容量已经满时，则将最近最少使用的Page淘汰，即链表的最后一个节点，再将该Page放置到BufferPool中。\n这就是LRU(Last Recently Used, 最近最少使用)算法的思想，在实际的移动、删除和添加操作时，经常引入虚拟头结点和尾节点，使得在具体操作时,不必判断相邻节点是否存在。\n\n一个最简单的LRU算法实现版本如下：LRU缓存\nclass LRUCache &#123;\n    &#x2F;&#x2F; 定义一个双向链表\n    class DoubleLinedList&#123;\n        int key;\n        int value;\n        DoubleLinedList prev;\n        DoubleLinedList next;\n\n        public DoubleLinedList()&#123;&#125;\n\n        public DoubleLinedList(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n\n    private Map&lt;Integer, DoubleLinedList&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    &#x2F;&#x2F; 虚拟头结点和尾节点\n    &#x2F;&#x2F; 使得在插入和删除节点操作时,不必判断相邻节点是否存在\n    private DoubleLinedList head, tail;\n    private int size;\n    private int capacity;\n\n    public LRUCache(int capacity) &#123;\n        &#x2F;&#x2F; initialize\n        this.capacity &#x3D; capacity;\n        this.size &#x3D; 0;\n        head &#x3D; new DoubleLinedList();\n        tail &#x3D; new DoubleLinedList();\n        head.next &#x3D; tail;\n        tail.prev &#x3D; head;\n    &#125;\n\n    public int get(int key) &#123;\n         DoubleLinedList node &#x3D; map.get(key);\n         &#x2F;&#x2F; 节点存在，需要移动到头部\n        if(node &#x3D;&#x3D; null)&#123;\n           return -1;\n        &#125;\n        movetoHead(node);\n        return node.value;\n    &#125;\n\n    public void put(int key, int value) &#123;\n        DoubleLinedList node &#x3D; map.get(key);\n        &#x2F;&#x2F; 节点存在，需要更新值，并移动到头部\n        if(node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            movetoHead(node);\n        &#125;\n        else&#123;\n            &#x2F;&#x2F; 创建节点\n            DoubleLinedList newNode &#x3D; new DoubleLinedList(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            size++;\n            &#x2F;&#x2F; 如果超出了容量，需要删除最久未使用的节点，就是虚拟伪节点的前一个节点\n            if(size &gt; capacity)&#123;\n                DoubleLinedList lastNode &#x3D; romoveLastUsed();\n                removeNode(lastNode);\n                map.remove(lastNode.key);\n                size--;\n            &#125;\n\n        &#125;\n\n    &#125;\n    &#x2F;&#x2F; 向头部插入节点\n    private void addToHead(DoubleLinedList node)&#123;\n        node.next &#x3D; head.next;\n        node.prev &#x3D; head;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n    &#125;\n\n    &#x2F;&#x2F; 删除节点,即直接跳过该节点\n    private void removeNode(DoubleLinedList node)&#123;\n        node.prev.next &#x3D; node.next;\n        node.next.prev &#x3D; node.prev;\n\n    &#125;\n\n    &#x2F;&#x2F; 将最近被使用的节点移动到头部,但是要先在原来的位置删除该节点\n    private void movetoHead(DoubleLinedList node)&#123;\n        removeNode(node);\n        addToHead(node);\n    &#125;\n\n    &#x2F;&#x2F; 返回最久未使用的节点,即虚拟节点的前一个节点\n    private DoubleLinedList romoveLastUsed()&#123;\n        DoubleLinedList cur &#x3D; tail.prev;\n        &#x2F;&#x2F; removeNode(cur);\n        return cur;\n    &#125;\n&#125;\n\nComment:\n时间复杂度：O(1)\n空间复杂度：O(n)\n","slug":"LRU缓存算法","date":"2023-07-04T07:30:07.000Z","categories_index":"","tags_index":"project","author_index":"Qin Zehao"},{"id":"4f4fe6709de0267b7f3da59b044be8c2","title":"Leetcode417_水流问题","content":"题目描述\nLeetcode417-太平洋大西洋水流问题\n有一个m x n的矩形岛屿，与 太平洋和大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。\n这个岛被分割成一个由若干方形单元格组成的网格。给定一个m x n的整数矩阵*heights, **heights[i][j]表示坐标(r, c)*上单元格相对于海平面的高度 。\n岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。\n*返回单元格坐标result的2D列表 ，其中**result[i] = [ri, ci]表示雨水从单元格(ri, ci)*流动既可流向太平洋也可流向大西洋。\n示例 1：\n输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n示例 2：\n输入: heights = [[2,1],[1,2]]\n输出: [[0,0],[0,1],[1,0],[1,1]]\n\n思路: DFS(反向)· 最直接的做法是从每一个单元格开始，深度优先遍历其周围的单元格，模拟雨水的流动，判断是否能流   向两个大洋，但是这样会造成一个单元格被重复遍历多次。\n· 更好的思路是从矩阵的左边界和上边界开始反向搜索雨水可以流入太平洋的单元格，同理从矩阵的右边界和下边界反向搜索雨水可以流入大西洋的单元格。因为是反向遍历，只有当下一个搜索的单元格大于当前单元格的高度，雨水才能到达。\n· 如果一个单元格既可以从太平洋反向到达也可以从大西洋反向到达，就将其添加到答案result中。\n\n代码如下:\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; heights;\n    int m, n;\n    int dir[4][2] &#x3D; &#123;-1,0,1,0,0,-1,0,1&#125;;  &#x2F;&#x2F;方向数组\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; flag, int x,int y)&#123;\n        if(flag[x][y])\n           return;\n        flag[x][y] &#x3D; 1;  &#x2F;&#x2F;能反向流入就将其值置为1\n        for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n            int a &#x3D; x + dir[i][0];\n            int b &#x3D; y + dir[i][1];\n            if(a &lt; 0 || a &gt;&#x3D; m || b &lt; 0 || b &gt;&#x3D; n)\n                continue;\n            if(heights[a][b] &lt; heights[x][y])\n                continue;\n            dfs(flag, a, b);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;\n        this-&gt;heights &#x3D; heights;\n        m&#x3D;heights.size();\n        n&#x3D;heights[0].size();\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;vector&lt;int&gt;&gt; p(m,vector&lt;int&gt;(n,0));  &#x2F;&#x2F;判断能否流入太平洋\n        vector&lt;vector&lt;int&gt;&gt; a(m,vector&lt;int&gt;(n,0));  &#x2F;&#x2F;判断能否流入大西洋\n        &#x2F;&#x2F;从矩阵边界处开始反向搜索\n        for(int i &#x3D; 0; i &lt; m; i++)&#123;\n            dfs(p, i, 0);\n            dfs(a, i, n-1);\n        &#125;\n         for(int j &#x3D; 0; j &lt; n; j++)&#123;\n            dfs(p, 0, j);\n            dfs(a, m-1, j);\n        &#125;\n        for(int i &#x3D; 0; i &lt; m; i++)\n           for(int j &#x3D; 0; j &lt; n; j++)&#123;\n                &#x2F;&#x2F;能同时流入两个大洋的加入result\n                if(p[i][j] &amp;&amp; a[i][j])  \n                  result.push_back(&#123;i,j&#125;);\n            &#125;\n        return result;\n    &#125;\n&#125;;\n\nComment:\n时间复杂度：O(mn), 每个单元格最多被遍历两次\n空间复杂度：O(mn)\n","slug":"Leetcode417-水流问题","date":"2022-12-18T01:44:54.000Z","categories_index":"","tags_index":"Leetcode","author_index":"Qin Zehao"},{"id":"0611e9ed1fdeb61defdbe1f2f9a19cf6","title":"Leetcode934_最短的桥","content":"题目描述\nLeetcode934-最短的桥\n给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。\n岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛\n你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。\n返回必须翻转的 0 的最小数目。\n示例 1：\n输入：grid = [[0,1],[1,0]]输出：1\n示例 2：\n输入：grid = [[0,1,0],[0,0,0],[0,0,1]]输出：2\n示例 3：\n输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]输出：1\n\n思路: DFS + BFS· 遍历grid时，先利用深度优先搜索找到其中一座岛，得到第一座岛的位置集合，遍历过的位置都标记为-1\n· 从所有第一座岛的位置开始出发，向外扩展进行广度优先搜索，当达到任意的1时，即找到了第二座岛，扩展的层数就是桥的最短距离\n\n代码如下：\nclass Solution &#123;\npublic:\n    int dir[4][2] &#x3D; &#123;-1,0,1,0,0,-1,0,1&#125;;  &#x2F;&#x2F;方向数组\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n\n    void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        q.push(&#123;x, y&#125;);\n        grid[x][y] &#x3D; -1;\n        int n &#x3D; grid.size();\n        for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n            int a &#x3D; x + dir[i][0];\n            int b &#x3D; y + dir[i][1];\n            if(a &lt; 0 || a &gt;&#x3D;n || b &lt; 0 || b &gt;&#x3D;n)\n                continue;\n            if(grid[a][b] &#x3D;&#x3D; 1)\n                dfs(a, b, grid); \n        &#125;\n        return;\n    &#125;\n\n    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        bool flag &#x3D; false;\n        for (int i &#x3D; 0; i &lt; n; i++)&#123;\n            for (int j &#x3D; 0; j &lt; n; j++)&#123;\n                if (grid[i][j] &#x3D;&#x3D; 1)&#123;\n                    flag &#x3D; true;\n                    dfs(i, j, grid);\n                    break;  &#x2F;&#x2F;由于只有两座岛，找到一座就break\n                &#125;\n            &#125;\n            if(flag)\n               break;\n        &#125;\n        \n        int bridge &#x3D; 0;\n        while(!q.empty())&#123;\n            int size &#x3D; q.size();\n            for (int i &#x3D; 0; i &lt; size; i++)&#123;\n                pair&lt;int,int&gt;  t &#x3D; q.front();\n                int x &#x3D; t.first;\n                int y &#x3D; t.second;\n                q.pop();\n                for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n                    int a &#x3D; x + dir[i][0];\n                    int b &#x3D; y + dir[i][1];\n                    if(a &lt; 0 || a &gt;&#x3D;n || b &lt; 0 || b &gt;&#x3D;n)\n                        continue;\n                    if(grid[a][b] &#x3D;&#x3D; 0)&#123;\n                        q.push(&#123;a, b&#125;);\n                        grid[a][b] &#x3D; -1;\n                    &#125;\n                    if(grid[a][b] &#x3D;&#x3D; 1)\n                        return bridge;\n                &#125;\n            &#125;\n            bridge++;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\nComment:\n时间复杂度：O(n²)\n空间复杂度：O(n²)\n","slug":"Leetcode934-最短的桥","date":"2022-11-09T08:10:13.000Z","categories_index":"","tags_index":"Leetcode","author_index":"Qin Zehao"},{"id":"fb400ec9fdd913dd982407d3be3c8029","title":"Leetcode76_最小覆盖子串","content":"题目描述\nLeetcode76-最小覆盖子串\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。\n示例 1：\n输入：s = “ADOBECODEBANC”, t = “ABC”输出：”BANC”示例 2：\n输入：s = “a”, t = “aa”输出：””\n\n子串问题一般都采用滑动串口(Sliding Window)，采用一位大神的算法框架：void sliding_window(string s, string t)&#123;\n    unordered_map&lt;char, int&gt; target, window;\n    for (char c : t) target[c]++;\n    \n    int left &#x3D; 0, right &#x3D; 0;  &#x2F;&#x2F;滑动窗口左右指针\n    while (right &lt; s.size()) &#123;\n        char a &#x3D; s[right++];  &#x2F;&#x2F;字符移入窗口，并将窗口右移\n        &#x2F;*\n        更新窗口...\n        *&#x2F;\n        \n        &#x2F;*\n        debug 输出位置 \n        cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right;  &#x2F;&#x2F;检查左右指针位置\n        *&#x2F;\n        \n        &#x2F;&#x2F;判断左侧窗口是否需要收缩\n        while (if window needs to shrink) &#123;\n            char b &#x3D; s[left++]; &#x2F;&#x2F;字符移出窗口，并将窗口左移\n            &#x2F;*\n            更新窗口...\n            *&#x2F;\n        &#125;\n    &#125;\n&#125;\n\n\n对于这里，采用滑动窗口思路如下：\n先不断右移right 指针扩大窗口范围，直到窗口中的子串符合要求，即能够包含t中所有字符\n\n此时right指针停止移动，不断右移 left 指针缩小窗口，直到窗口中的子串不再符合要求，即不能包含t 中的所有字符了。同时，每次增加 left，我们都要更新一轮结果。\n\n重复前两步，left指针右移事同时更新结果，直到 right指针扫描完字符串 s。第1步相当于找到了一个可行解，第2步则优化该可行解。\n\n\n\n代码如下：\nclass Solution &#123;\npublic:\n    string minWindow(string s, string t) &#123;\n        &#x2F;&#x2F;哈希表+滑动窗口\n        unordered_map&lt;char, int&gt; target, current;\n            for(char c : t)\n            target[c]++;\n        \n        int vaild &#x3D; 0; &#x2F;&#x2F;记录t字符串的覆盖情况\n        int length &#x3D; INT_MAX; &#x2F;&#x2F;跟新最小满足情况的子串长度\n        int start &#x3D; 0; &#x2F;&#x2F;记录满足条件的子串的起始位置\n        int l &#x3D; 0,r &#x3D; 0;  &#x2F;&#x2F;滑动窗口左右指针\n        string ans;\n        \n        while(r &lt; s.size())&#123;\n            char a &#x3D; s[r++];  &#x2F;&#x2F;字符移入窗口，并将窗口右移\n            if(target.count(a))&#123;\n                current[a]++;\n                if(target[a] &#x3D;&#x3D; current[a])\n                   vaild++;\n           &#125;\n            &#x2F;&#x2F;找到可行解的同时开始收缩窗口大小，直到窗口内的子串不符合情况\n           while(vaild &#x3D;&#x3D; target.size())&#123;\n                &#x2F;&#x2F;更新可行解\n                if(length &gt; r-l)&#123;\n                    start &#x3D; l;\n                    length &#x3D; r-l;\n                &#125;\n                char b &#x3D; s[l++];  &#x2F;&#x2F;字符移出窗口，并将窗口左移\n                if(target.count(b))&#123;\n                    if(target[b] &#x3D;&#x3D; current[b])\n                       vaild--;\n                    current[b]--;\n                &#125;\n           &#125;\n        &#125;\n        if(length &#x3D;&#x3D; INT_MAX)\n           return &quot;&quot;;\n        else\n           return s.substr(start, length);\n    &#125;\n&#125;;\n\nComment:\n时间复杂度：O(n)\n空间复杂度：O(n)\n","slug":"Leetcode76-最小覆盖子串","date":"2022-10-22T12:19:35.000Z","categories_index":"","tags_index":"Leetcode","author_index":"Qin Zehao"},{"id":"6e2dd14b73e37cbb59872829cb647f57","title":"First Blog","content":"First Blog建立的初衷是希望能坚持写下去，改掉划水的习惯，能不断变好，单纯记录学习。\n——2022.10.22\n","slug":"First Blog","date":"2022-10-22T08:55:13.000Z","categories_index":"","tags_index":"daily","author_index":"Qin Zehao"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-22T04:27:25.948Z","categories_index":"","tags_index":"daily","author_index":"Qin Zehao"}]