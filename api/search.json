[{"id":"61cb2404786c8e041ac91f953c81aea7","title":"Linux下Redis的使用","content":"CentOS 7虚拟机下Redis的启动和使用常用命令如下（使用这些命令前要先配置系统服务文件）：\n\n启动Redis： –  systemctl start redis\n查看Redis运行状态： –  systemctl status redis  或 –  ps -ef | grep redis\n停止Redis： –  systemctl stop redis\n设置开机自启： –  systemctl enable redis\n使用Redis命令行客户端： –  redis-cli -a password\n退出Redis命令行客户端： –  stop/quit/Ctrl + D\n\n使用Redis图形化客户端：\ngithub地址：https://github.com/uglide/RedisDesktopManager\n安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\n打开图形化客户端（RESP）的连接，设置相应的连接名，输入IP地址和Rdis密码后即可使用\n查看CentOS 7虚拟机IP的命令： –  ifconfig\n\n","slug":"Linux下Redis的使用","date":"2023-07-09T09:35:15.000Z","categories_index":"","tags_index":"","author_index":"秦泽昊"},{"id":"3405a51be28fbdb1c58ecac6d40a5d4d","title":"LRU缓存算法","content":"LRU缓存\n最近在做6.830 Lab2时涉及到了实现BufferPool中的eviction policy，即页面置换算法，简单来说，PageId与Page的映射关系为HashMap&lt;PageId, LinkedNode&gt; bufferPool，LinkedNode是自定义双向链表节点，节点内保存了PageId和Page，以及前驱和后继节点prev、next。每当BufferPool中的Page被访问时，将该PageId对应的LinkedNode移动到链表的头部。同时当有Page需要放置到BufferPool中，且BufferPool的容量已经满时，则将最近最少使用的Page淘汰，即链表的最后一个节点，再将该Page放置到BufferPool中。\n这就是LRU(Last Recently Used, 最近最少使用)算法的思想，在实际的移动、删除和添加操作时，经常引入虚拟头结点和尾节点，使得在具体操作时,不必判断相邻节点是否存在。\n\n一个最简单的LRU算法实现版本如下：LRU缓存\nclass LRUCache &#123;\n    &#x2F;&#x2F; 定义一个双向链表\n    class DoubleLinedList&#123;\n        int key;\n        int value;\n        DoubleLinedList prev;\n        DoubleLinedList next;\n\n        public DoubleLinedList()&#123;&#125;\n\n        public DoubleLinedList(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n\n    private Map&lt;Integer, DoubleLinedList&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    &#x2F;&#x2F; 虚拟头结点和尾节点\n    &#x2F;&#x2F; 使得在插入和删除节点操作时,不必判断相邻节点是否存在\n    private DoubleLinedList head, tail;\n    private int size;\n    private int capacity;\n\n    public LRUCache(int capacity) &#123;\n        &#x2F;&#x2F; initialize\n        this.capacity &#x3D; capacity;\n        this.size &#x3D; 0;\n        head &#x3D; new DoubleLinedList();\n        tail &#x3D; new DoubleLinedList();\n        head.next &#x3D; tail;\n        tail.prev &#x3D; head;\n    &#125;\n\n    public int get(int key) &#123;\n         DoubleLinedList node &#x3D; map.get(key);\n         &#x2F;&#x2F; 节点存在，需要移动到头部\n        if(node &#x3D;&#x3D; null)&#123;\n           return -1;\n        &#125;\n        movetoHead(node);\n        return node.value;\n    &#125;\n\n    public void put(int key, int value) &#123;\n        DoubleLinedList node &#x3D; map.get(key);\n        &#x2F;&#x2F; 节点存在，需要更新值，并移动到头部\n        if(node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            movetoHead(node);\n        &#125;\n        else&#123;\n            &#x2F;&#x2F; 创建节点\n            DoubleLinedList newNode &#x3D; new DoubleLinedList(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            size++;\n            &#x2F;&#x2F; 如果超出了容量，需要删除最久未使用的节点，就是虚拟伪节点的前一个节点\n            if(size &gt; capacity)&#123;\n                DoubleLinedList lastNode &#x3D; romoveLastUsed();\n                removeNode(lastNode);\n                map.remove(lastNode.key);\n                size--;\n            &#125;\n\n        &#125;\n\n    &#125;\n    &#x2F;&#x2F; 向头部插入节点\n    private void addToHead(DoubleLinedList node)&#123;\n        node.next &#x3D; head.next;\n        node.prev &#x3D; head;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n    &#125;\n\n    &#x2F;&#x2F; 删除节点,即直接跳过该节点\n    private void removeNode(DoubleLinedList node)&#123;\n        node.prev.next &#x3D; node.next;\n        node.next.prev &#x3D; node.prev;\n\n    &#125;\n\n    &#x2F;&#x2F; 将最近被使用的节点移动到头部,但是要先在原来的位置删除该节点\n    private void movetoHead(DoubleLinedList node)&#123;\n        removeNode(node);\n        addToHead(node);\n    &#125;\n\n    &#x2F;&#x2F; 返回最久未使用的节点,即虚拟节点的前一个节点\n    private DoubleLinedList romoveLastUsed()&#123;\n        DoubleLinedList cur &#x3D; tail.prev;\n        &#x2F;&#x2F; removeNode(cur);\n        return cur;\n    &#125;\n&#125;\n\nComment:\n时间复杂度：O(1)\n空间复杂度：O(n)\n","slug":"LRU缓存算法","date":"2023-07-04T07:30:07.000Z","categories_index":"","tags_index":"","author_index":"秦泽昊"},{"id":"4f4fe6709de0267b7f3da59b044be8c2","title":"Leetcode417_水流问题","content":"题目描述\nLeetcode417-太平洋大西洋水流问题\n有一个m x n的矩形岛屿，与 太平洋和大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。\n这个岛被分割成一个由若干方形单元格组成的网格。给定一个m x n的整数矩阵*heights, **heights[i][j]表示坐标(r, c)*上单元格相对于海平面的高度 。\n岛上雨水较多，如果相邻单元格的高度小于或等于当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。\n*返回单元格坐标result的2D列表 ，其中**result[i] = [ri, ci]表示雨水从单元格(ri, ci)*流动既可流向太平洋也可流向大西洋。\n示例 1：\n输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n示例 2：\n输入: heights = [[2,1],[1,2]]\n输出: [[0,0],[0,1],[1,0],[1,1]]\n\n思路: DFS(反向)· 最直接的做法是从每一个单元格开始，深度优先遍历其周围的单元格，模拟雨水的流动，判断是否能流   向两个大洋，但是这样会造成一个单元格被重复遍历多次。\n· 更好的思路是从矩阵的左边界和上边界开始反向搜索雨水可以流入太平洋的单元格，同理从矩阵的右边界和下边界反向搜索雨水可以流入大西洋的单元格。因为是反向遍历，只有当下一个搜索的单元格大于当前单元格的高度，雨水才能到达。\n· 如果一个单元格既可以从太平洋反向到达也可以从大西洋反向到达，就将其添加到答案result中。\n\n代码如下:\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; heights;\n    int m, n;\n    int dir[4][2] &#x3D; &#123;-1,0,1,0,0,-1,0,1&#125;;  &#x2F;&#x2F;方向数组\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; flag, int x,int y)&#123;\n        if(flag[x][y])\n           return;\n        flag[x][y] &#x3D; 1;  &#x2F;&#x2F;能反向流入就将其值置为1\n        for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n            int a &#x3D; x + dir[i][0];\n            int b &#x3D; y + dir[i][1];\n            if(a &lt; 0 || a &gt;&#x3D; m || b &lt; 0 || b &gt;&#x3D; n)\n                continue;\n            if(heights[a][b] &lt; heights[x][y])\n                continue;\n            dfs(flag, a, b);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;\n        this-&gt;heights &#x3D; heights;\n        m&#x3D;heights.size();\n        n&#x3D;heights[0].size();\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;vector&lt;int&gt;&gt; p(m,vector&lt;int&gt;(n,0));  &#x2F;&#x2F;判断能否流入太平洋\n        vector&lt;vector&lt;int&gt;&gt; a(m,vector&lt;int&gt;(n,0));  &#x2F;&#x2F;判断能否流入大西洋\n        &#x2F;&#x2F;从矩阵边界处开始反向搜索\n        for(int i &#x3D; 0; i &lt; m; i++)&#123;\n            dfs(p, i, 0);\n            dfs(a, i, n-1);\n        &#125;\n         for(int j &#x3D; 0; j &lt; n; j++)&#123;\n            dfs(p, 0, j);\n            dfs(a, m-1, j);\n        &#125;\n        for(int i &#x3D; 0; i &lt; m; i++)\n           for(int j &#x3D; 0; j &lt; n; j++)&#123;\n                &#x2F;&#x2F;能同时流入两个大洋的加入result\n                if(p[i][j] &amp;&amp; a[i][j])  \n                  result.push_back(&#123;i,j&#125;);\n            &#125;\n        return result;\n    &#125;\n&#125;;\n\nComment:\n时间复杂度：O(mn), 每个单元格最多被遍历两次\n空间复杂度：O(mn)\n","slug":"Leetcode417-水流问题","date":"2022-12-18T01:44:54.000Z","categories_index":"","tags_index":"","author_index":"秦泽昊"},{"id":"0611e9ed1fdeb61defdbe1f2f9a19cf6","title":"Leetcode934_最短的桥","content":"题目描述\nLeetcode934-最短的桥\n给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。\n岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛\n你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。\n返回必须翻转的 0 的最小数目。\n示例 1：\n输入：grid = [[0,1],[1,0]]输出：1\n示例 2：\n输入：grid = [[0,1,0],[0,0,0],[0,0,1]]输出：2\n示例 3：\n输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]输出：1\n\n思路: DFS + BFS· 遍历grid时，先利用深度优先搜索找到其中一座岛，得到第一座岛的位置集合，遍历过的位置都标记为-1\n· 从所有第一座岛的位置开始出发，向外扩展进行广度优先搜索，当达到任意的1时，即找到了第二座岛，扩展的层数就是桥的最短距离\n\n代码如下：\nclass Solution &#123;\npublic:\n    int dir[4][2] &#x3D; &#123;-1,0,1,0,0,-1,0,1&#125;;  &#x2F;&#x2F;方向数组\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n\n    void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        q.push(&#123;x, y&#125;);\n        grid[x][y] &#x3D; -1;\n        int n &#x3D; grid.size();\n        for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n            int a &#x3D; x + dir[i][0];\n            int b &#x3D; y + dir[i][1];\n            if(a &lt; 0 || a &gt;&#x3D;n || b &lt; 0 || b &gt;&#x3D;n)\n                continue;\n            if(grid[a][b] &#x3D;&#x3D; 1)\n                dfs(a, b, grid); \n        &#125;\n        return;\n    &#125;\n\n    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        bool flag &#x3D; false;\n        for (int i &#x3D; 0; i &lt; n; i++)&#123;\n            for (int j &#x3D; 0; j &lt; n; j++)&#123;\n                if (grid[i][j] &#x3D;&#x3D; 1)&#123;\n                    flag &#x3D; true;\n                    dfs(i, j, grid);\n                    break;  &#x2F;&#x2F;由于只有两座岛，找到一座就break\n                &#125;\n            &#125;\n            if(flag)\n               break;\n        &#125;\n        \n        int bridge &#x3D; 0;\n        while(!q.empty())&#123;\n            int size &#x3D; q.size();\n            for (int i &#x3D; 0; i &lt; size; i++)&#123;\n                pair&lt;int,int&gt;  t &#x3D; q.front();\n                int x &#x3D; t.first;\n                int y &#x3D; t.second;\n                q.pop();\n                for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n                    int a &#x3D; x + dir[i][0];\n                    int b &#x3D; y + dir[i][1];\n                    if(a &lt; 0 || a &gt;&#x3D;n || b &lt; 0 || b &gt;&#x3D;n)\n                        continue;\n                    if(grid[a][b] &#x3D;&#x3D; 0)&#123;\n                        q.push(&#123;a, b&#125;);\n                        grid[a][b] &#x3D; -1;\n                    &#125;\n                    if(grid[a][b] &#x3D;&#x3D; 1)\n                        return bridge;\n                &#125;\n            &#125;\n            bridge++;\n        &#125;\n        return 0;\n    &#125;\n&#125;;\n\nComment:\n时间复杂度：O(n²)\n空间复杂度：O(n²)\n","slug":"Leetcode934-最短的桥","date":"2022-11-09T08:10:13.000Z","categories_index":"","tags_index":"","author_index":"秦泽昊"},{"id":"fb400ec9fdd913dd982407d3be3c8029","title":"Leetcode76_最小覆盖子串","content":"题目描述\nLeetcode76-最小覆盖子串\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。\n示例 1：\n输入：s = “ADOBECODEBANC”, t = “ABC”输出：”BANC”示例 2：\n输入：s = “a”, t = “aa”输出：””\n\n子串问题一般都采用滑动串口(Sliding Window)，采用一位大神的算法框架：void sliding_window(string s, string t)&#123;\n    unordered_map&lt;char, int&gt; target, window;\n    for (char c : t) target[c]++;\n    \n    int left &#x3D; 0, right &#x3D; 0;  &#x2F;&#x2F;滑动窗口左右指针\n    while (right &lt; s.size()) &#123;\n        char a &#x3D; s[right++];  &#x2F;&#x2F;字符移入窗口，并将窗口右移\n        &#x2F;*\n        更新窗口...\n        *&#x2F;\n        \n        &#x2F;*\n        debug 输出位置 \n        cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right;  &#x2F;&#x2F;检查左右指针位置\n        *&#x2F;\n        \n        &#x2F;&#x2F;判断左侧窗口是否需要收缩\n        while (if window needs to shrink) &#123;\n            char b &#x3D; s[left++]; &#x2F;&#x2F;字符移出窗口，并将窗口左移\n            &#x2F;*\n            更新窗口...\n            *&#x2F;\n        &#125;\n    &#125;\n&#125;\n\n\n对于这里，采用滑动窗口思路如下：\n先不断右移right 指针扩大窗口范围，直到窗口中的子串符合要求，即能够包含t中所有字符\n\n此时right指针停止移动，不断右移 left 指针缩小窗口，直到窗口中的子串不再符合要求，即不能包含t 中的所有字符了。同时，每次增加 left，我们都要更新一轮结果。\n\n重复前两步，left指针右移事同时更新结果，直到 right指针扫描完字符串 s。第1步相当于找到了一个可行解，第2步则优化该可行解。\n\n\n\n代码如下：\nclass Solution &#123;\npublic:\n    string minWindow(string s, string t) &#123;\n        &#x2F;&#x2F;哈希表+滑动窗口\n        unordered_map&lt;char, int&gt; target, current;\n            for(char c : t)\n            target[c]++;\n        \n        int vaild &#x3D; 0; &#x2F;&#x2F;记录t字符串的覆盖情况\n        int length &#x3D; INT_MAX; &#x2F;&#x2F;跟新最小满足情况的子串长度\n        int start &#x3D; 0; &#x2F;&#x2F;记录满足条件的子串的起始位置\n        int l &#x3D; 0,r &#x3D; 0;  &#x2F;&#x2F;滑动窗口左右指针\n        string ans;\n        \n        while(r &lt; s.size())&#123;\n            char a &#x3D; s[r++];  &#x2F;&#x2F;字符移入窗口，并将窗口右移\n            if(target.count(a))&#123;\n                current[a]++;\n                if(target[a] &#x3D;&#x3D; current[a])\n                   vaild++;\n           &#125;\n            &#x2F;&#x2F;找到可行解的同时开始收缩窗口大小，直到窗口内的子串不符合情况\n           while(vaild &#x3D;&#x3D; target.size())&#123;\n                &#x2F;&#x2F;更新可行解\n                if(length &gt; r-l)&#123;\n                    start &#x3D; l;\n                    length &#x3D; r-l;\n                &#125;\n                char b &#x3D; s[l++];  &#x2F;&#x2F;字符移出窗口，并将窗口左移\n                if(target.count(b))&#123;\n                    if(target[b] &#x3D;&#x3D; current[b])\n                       vaild--;\n                    current[b]--;\n                &#125;\n           &#125;\n        &#125;\n        if(length &#x3D;&#x3D; INT_MAX)\n           return &quot;&quot;;\n        else\n           return s.substr(start, length);\n    &#125;\n&#125;;\n\nComment:\n时间复杂度：O(n)\n空间复杂度：O(n)\n","slug":"Leetcode76-最小覆盖子串","date":"2022-10-22T12:19:35.000Z","categories_index":"","tags_index":"","author_index":"秦泽昊"},{"id":"6e2dd14b73e37cbb59872829cb647f57","title":"First Blog","content":"First Blog建立的初衷是希望能坚持写下去，改掉划水的习惯，能不断变好，单纯记录学习。\n——2022.10.22\n","slug":"First Blog","date":"2022-10-22T08:55:13.000Z","categories_index":"","tags_index":"","author_index":"秦泽昊"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-22T04:27:25.948Z","categories_index":"","tags_index":"","author_index":"秦泽昊"}]