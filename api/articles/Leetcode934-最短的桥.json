{"title":"Leetcode934_最短的桥","uid":"0611e9ed1fdeb61defdbe1f2f9a19cf6","slug":"Leetcode934-最短的桥","date":"2022-11-09T08:10:13.000Z","updated":"2022-12-17T15:08:02.653Z","comments":true,"path":"api/articles/Leetcode934-最短的桥.json","keywords":null,"cover":null,"content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a><strong>题目描述</strong></h2><hr>\n<p><a href=\"https://leetcode.cn/problems/shortest-bridge/\">Leetcode934-最短的桥</a></p>\n<p><em>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。</em></p>\n<p><em>岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛</em></p>\n<p><em>你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。</em></p>\n<p><em>返回必须翻转的 0 的最小数目。</em></p>\n<p><em>示例 1：</em></p>\n<p><em>输入：grid = [[0,1],[1,0]]</em><br><em>输出：1</em></p>\n<p><em>示例 2：</em></p>\n<p><em>输入：grid = [[0,1,0],[0,0,0],[0,0,1]]</em><br><em>输出：2</em></p>\n<p><em>示例 3：</em></p>\n<p><em>输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</em></p>\n<hr>\n<h4 id=\"思路-DFS-BFS\"><a href=\"#思路-DFS-BFS\" class=\"headerlink\" title=\"思路: DFS + BFS\"></a><strong>思路: DFS + BFS</strong></h4><p><strong>· 遍历grid时，先利用深度优先搜索找到其中一座岛，得到第一座岛的位置集合，遍历过的位置都标记为-1</strong></p>\n<p><strong>· 从所有第一座岛的位置开始出发，向外扩展进行广度优先搜索，当达到任意的1时，即找到了第二座岛，扩展的层数就是桥的最短距离</strong></p>\n<hr>\n<p><strong>代码如下：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dir[4][2] &#x3D; &#123;-1,0,1,0,0,-1,0,1&#125;;  &#x2F;&#x2F;方向数组\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n\n    void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        q.push(&#123;x, y&#125;);\n        grid[x][y] &#x3D; -1;\n        int n &#x3D; grid.size();\n        for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n            int a &#x3D; x + dir[i][0];\n            int b &#x3D; y + dir[i][1];\n            if(a &lt; 0 || a &gt;&#x3D;n || b &lt; 0 || b &gt;&#x3D;n)\n                continue;\n            if(grid[a][b] &#x3D;&#x3D; 1)\n                dfs(a, b, grid); \n        &#125;\n        return;\n    &#125;\n\n    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        bool flag &#x3D; false;\n        for (int i &#x3D; 0; i &lt; n; i++)&#123;\n            for (int j &#x3D; 0; j &lt; n; j++)&#123;\n                if (grid[i][j] &#x3D;&#x3D; 1)&#123;\n                    flag &#x3D; true;\n                    dfs(i, j, grid);\n                    break;  &#x2F;&#x2F;由于只有两座岛，找到一座就break\n                &#125;\n            &#125;\n            if(flag)\n               break;\n        &#125;\n        \n        int bridge &#x3D; 0;\n        while(!q.empty())&#123;\n            int size &#x3D; q.size();\n            for (int i &#x3D; 0; i &lt; size; i++)&#123;\n                pair&lt;int,int&gt;  t &#x3D; q.front();\n                int x &#x3D; t.first;\n                int y &#x3D; t.second;\n                q.pop();\n                for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n                    int a &#x3D; x + dir[i][0];\n                    int b &#x3D; y + dir[i][1];\n                    if(a &lt; 0 || a &gt;&#x3D;n || b &lt; 0 || b &gt;&#x3D;n)\n                        continue;\n                    if(grid[a][b] &#x3D;&#x3D; 0)&#123;\n                        q.push(&#123;a, b&#125;);\n                        grid[a][b] &#x3D; -1;\n                    &#125;\n                    if(grid[a][b] &#x3D;&#x3D; 1)\n                        return bridge;\n                &#125;\n            &#125;\n            bridge++;\n        &#125;\n        return 0;\n    &#125;\n&#125;;</code></pre>\n\n<p><strong>Comment:</strong></p>\n<p><strong>时间复杂度：O(n²)</strong></p>\n<p><strong>空间复杂度：O(n²)</strong></p>\n","feature":true,"text":"题目描述 Leetcode934-最短的桥 给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。 岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 你可以将任意数量的 0 变为 1 ，以使两...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-DFS-BFS\"><span class=\"toc-text\">思路: DFS + BFS</span></a></li></ol></li></ol></li></ol>","author":{"name":"秦泽昊","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Leetcode417_水流问题","uid":"4f4fe6709de0267b7f3da59b044be8c2","slug":"Leetcode417-水流问题","date":"2022-12-18T01:44:54.000Z","updated":"2022-12-18T02:06:25.044Z","comments":true,"path":"api/articles/Leetcode417-水流问题.json","keywords":null,"cover":null,"text":"题目描述 Leetcode417-太平洋大西洋水流问题 有一个m x n的矩形岛屿，与 太平洋和大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。 这个岛被分割成一个由若干方形单元格组成的网格。给定一个m x n的整数矩阵*heigh...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"秦泽昊","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Leetcode76_最小覆盖子串","uid":"fb400ec9fdd913dd982407d3be3c8029","slug":"Leetcode76-最小覆盖子串","date":"2022-10-22T12:19:35.000Z","updated":"2022-12-17T15:14:10.431Z","comments":true,"path":"api/articles/Leetcode76-最小覆盖子串.json","keywords":null,"cover":null,"text":"题目描述 Leetcode76-最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"秦泽昊","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}