{"title":"Leetcode76_最小覆盖子串","uid":"fb400ec9fdd913dd982407d3be3c8029","slug":"Leetcode76-最小覆盖子串","date":"2022-10-22T12:19:35.000Z","updated":"2022-12-17T15:14:10.431Z","comments":true,"path":"api/articles/Leetcode76-最小覆盖子串.json","keywords":null,"cover":null,"content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><hr>\n<p><a href=\"https://leetcode.cn/problems/minimum-window-substring/\">Leetcode76-最小覆盖子串</a></p>\n<p><em>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</em></p>\n<p><em>注意：</em></p>\n<p><em>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</em><br><em>如果 s 中存在这样的子串，我们保证它是唯一的答案。</em></p>\n<p><em>示例 1：</em></p>\n<p><em>输入：s = “ADOBECODEBANC”, t = “ABC”</em><br><em>输出：”BANC”</em><br><em>示例 2：</em></p>\n<p><em>输入：s = “a”, t = “aa”</em><br><em>输出：””</em></p>\n<hr>\n<h4 id=\"子串问题一般都采用滑动串口-Sliding-Window-，采用一位大神的算法框架：\"><a href=\"#子串问题一般都采用滑动串口-Sliding-Window-，采用一位大神的算法框架：\" class=\"headerlink\" title=\"子串问题一般都采用滑动串口(Sliding Window)，采用一位大神的算法框架：\"></a>子串问题一般都采用滑动串口(Sliding Window)，采用一位大神的算法框架：</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void sliding_window(string s, string t)&#123;\n    unordered_map&lt;char, int&gt; target, window;\n    for (char c : t) target[c]++;\n    \n    int left &#x3D; 0, right &#x3D; 0;  &#x2F;&#x2F;滑动窗口左右指针\n    while (right &lt; s.size()) &#123;\n        char a &#x3D; s[right++];  &#x2F;&#x2F;字符移入窗口，并将窗口右移\n        &#x2F;*\n        更新窗口...\n        *&#x2F;\n        \n        &#x2F;*\n        debug 输出位置 \n        cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right;  &#x2F;&#x2F;检查左右指针位置\n        *&#x2F;\n        \n        &#x2F;&#x2F;判断左侧窗口是否需要收缩\n        while (if window needs to shrink) &#123;\n            char b &#x3D; s[left++]; &#x2F;&#x2F;字符移出窗口，并将窗口左移\n            &#x2F;*\n            更新窗口...\n            *&#x2F;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<hr>\n<h3 id=\"对于这里，采用滑动窗口思路如下：\"><a href=\"#对于这里，采用滑动窗口思路如下：\" class=\"headerlink\" title=\"对于这里，采用滑动窗口思路如下：\"></a>对于这里，采用滑动窗口思路如下：</h3><ul>\n<li><p>先不断右移<strong>right</strong> 指针扩大窗口范围，直到窗口中的子串符合要求，即能够包含<strong>t</strong>中所有字符</p>\n</li>\n<li><p>此时<strong>right</strong>指针停止移动，不断右移 <strong>left</strong> 指针缩小窗口，直到窗口中的子串不再符合要求，即不能包含<strong>t</strong> 中的所有字符了。同时，每次增加 <strong>left</strong>，我们都要更新一轮结果。</p>\n</li>\n<li><p>重复前两步，<strong>left</strong>指针右移事同时更新结果，直到 <strong>right</strong>指针扫描完字符串 <strong>s</strong>。第1步相当于找到了一个可行解，第2步则优化该可行解。</p>\n</li>\n</ul>\n<hr>\n<p><strong>代码如下：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string minWindow(string s, string t) &#123;\n        &#x2F;&#x2F;哈希表+滑动窗口\n        unordered_map&lt;char, int&gt; target, current;\n            for(char c : t)\n            target[c]++;\n        \n        int vaild &#x3D; 0; &#x2F;&#x2F;记录t字符串的覆盖情况\n        int length &#x3D; INT_MAX; &#x2F;&#x2F;跟新最小满足情况的子串长度\n        int start &#x3D; 0; &#x2F;&#x2F;记录满足条件的子串的起始位置\n        int l &#x3D; 0,r &#x3D; 0;  &#x2F;&#x2F;滑动窗口左右指针\n        string ans;\n        \n        while(r &lt; s.size())&#123;\n            char a &#x3D; s[r++];  &#x2F;&#x2F;字符移入窗口，并将窗口右移\n            if(target.count(a))&#123;\n                current[a]++;\n                if(target[a] &#x3D;&#x3D; current[a])\n                   vaild++;\n           &#125;\n            &#x2F;&#x2F;找到可行解的同时开始收缩窗口大小，直到窗口内的子串不符合情况\n           while(vaild &#x3D;&#x3D; target.size())&#123;\n                &#x2F;&#x2F;更新可行解\n                if(length &gt; r-l)&#123;\n                    start &#x3D; l;\n                    length &#x3D; r-l;\n                &#125;\n                char b &#x3D; s[l++];  &#x2F;&#x2F;字符移出窗口，并将窗口左移\n                if(target.count(b))&#123;\n                    if(target[b] &#x3D;&#x3D; current[b])\n                       vaild--;\n                    current[b]--;\n                &#125;\n           &#125;\n        &#125;\n        if(length &#x3D;&#x3D; INT_MAX)\n           return &quot;&quot;;\n        else\n           return s.substr(start, length);\n    &#125;\n&#125;;</code></pre>\n\n<p><strong>Comment:</strong></p>\n<p><strong>时间复杂度：O(n)</strong></p>\n<p><strong>空间复杂度：O(n)</strong></p>\n","text":"题目描述 Leetcode76-最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98%E4%B8%80%E8%88%AC%E9%83%BD%E9%87%87%E7%94%A8%E6%BB%91%E5%8A%A8%E4%B8%B2%E5%8F%A3-Sliding-Window-%EF%BC%8C%E9%87%87%E7%94%A8%E4%B8%80%E4%BD%8D%E5%A4%A7%E7%A5%9E%E7%9A%84%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6%EF%BC%9A\"><span class=\"toc-text\">子串问题一般都采用滑动串口(Sliding Window)，采用一位大神的算法框架：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E4%BA%8E%E8%BF%99%E9%87%8C%EF%BC%8C%E9%87%87%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%80%9D%E8%B7%AF%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">对于这里，采用滑动窗口思路如下：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Leetcode934_最短的桥","uid":"0611e9ed1fdeb61defdbe1f2f9a19cf6","slug":"Leetcode934-最短的桥","date":"2022-11-09T08:10:13.000Z","updated":"2022-12-17T15:08:02.653Z","comments":true,"path":"api/articles/Leetcode934-最短的桥.json","keywords":null,"cover":null,"text":"题目描述 Leetcode934-最短的桥 给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。 岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 你可以将任意数量的 0 变为 1 ，以使两...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"First Blog","uid":"6e2dd14b73e37cbb59872829cb647f57","slug":"First Blog","date":"2022-10-22T08:55:13.000Z","updated":"2022-12-17T15:16:39.236Z","comments":true,"path":"api/articles/First Blog.json","keywords":null,"cover":null,"text":"First Blog建立的初衷是希望能坚持写下去，改掉划水的习惯，能不断变好，单纯记录学习。 ——2022.10.22 ","link":"","photos":[],"count_time":{"symbolsCount":60,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}