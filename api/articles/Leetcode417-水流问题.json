{"title":"Leetcode417_水流问题","uid":"4f4fe6709de0267b7f3da59b044be8c2","slug":"Leetcode417-水流问题","date":"2022-12-18T01:44:54.000Z","updated":"2022-12-18T02:06:25.044Z","comments":true,"path":"api/articles/Leetcode417-水流问题.json","keywords":null,"cover":null,"content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><hr>\n<p><a href=\"https://leetcode.cn/problems/pacific-atlantic-water-flow/\">Leetcode417-太平洋大西洋水流问题</a></p>\n<p><em>有一个<strong>m x n</strong>的矩形岛屿，与 太平洋和大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。</em></p>\n<p><em><strong>这个岛被分割成一个由若干方形单元格组成的网格。给定一个</strong>m x n</em><em>的整数矩阵*<em>heights</em></em>, **heights[i][j]<strong>表示坐标</strong>(r, c)*<em>上单元格相对于海平面的高度 。</em></p>\n<p><em>岛上雨水较多，如果相邻单元格的高度<strong>小于或等于</strong>当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</em></p>\n<p>*返回单元格坐标<strong>result</strong>的<strong>2D</strong>列表 ，其中**result[i] = [ri, ci]<strong>表示雨水从单元格</strong>(ri, ci)*<em>流动既可流向太平洋也可流向大西洋。</em></p>\n<p><em><strong>示例 1：</strong></em></p>\n<p><em>输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]</em></p>\n<p><em>输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</em></p>\n<p><em><strong>示例 2：</strong></em></p>\n<p><em>输入: heights = [[2,1],[1,2]]</em></p>\n<p><em>输出: [[0,0],[0,1],[1,0],[1,1]]</em></p>\n<hr>\n<h3 id=\"思路-DFS-反向\"><a href=\"#思路-DFS-反向\" class=\"headerlink\" title=\"思路: DFS(反向)\"></a>思路: DFS(反向)</h3><p>· 最直接的做法是从每一个单元格开始，深度优先遍历其周围的单元格，模拟雨水的流动，判断是否能流   向两个大洋，但是这样会造成一个单元格被重复遍历多次。</p>\n<p>· 更好的思路是从矩阵的左边界和上边界开始反向搜索雨水可以流入太平洋的单元格，同理从矩阵的右边界和下边界反向搜索雨水可以流入大西洋的单元格。<strong>因为是反向遍历，只有当下一个搜索的单元格大于当前单元格的高度，雨水才能到达。</strong></p>\n<p>· 如果一个单元格既可以从太平洋反向到达也可以从大西洋反向到达，就将其添加到答案<strong>result</strong>中。</p>\n<hr>\n<p><strong>代码如下</strong>:</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; heights;\n    int m, n;\n    int dir[4][2] &#x3D; &#123;-1,0,1,0,0,-1,0,1&#125;;  &#x2F;&#x2F;方向数组\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; flag, int x,int y)&#123;\n        if(flag[x][y])\n           return;\n        flag[x][y] &#x3D; 1;  &#x2F;&#x2F;能反向流入就将其值置为1\n        for(int i &#x3D; 0; i &lt; 4; i++)&#123;\n            int a &#x3D; x + dir[i][0];\n            int b &#x3D; y + dir[i][1];\n            if(a &lt; 0 || a &gt;&#x3D; m || b &lt; 0 || b &gt;&#x3D; n)\n                continue;\n            if(heights[a][b] &lt; heights[x][y])\n                continue;\n            dfs(flag, a, b);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;\n        this-&gt;heights &#x3D; heights;\n        m&#x3D;heights.size();\n        n&#x3D;heights[0].size();\n        vector&lt;vector&lt;int&gt;&gt; result;\n        vector&lt;vector&lt;int&gt;&gt; p(m,vector&lt;int&gt;(n,0));  &#x2F;&#x2F;判断能否流入太平洋\n        vector&lt;vector&lt;int&gt;&gt; a(m,vector&lt;int&gt;(n,0));  &#x2F;&#x2F;判断能否流入大西洋\n        &#x2F;&#x2F;从矩阵边界处开始反向搜索\n        for(int i &#x3D; 0; i &lt; m; i++)&#123;\n            dfs(p, i, 0);\n            dfs(a, i, n-1);\n        &#125;\n         for(int j &#x3D; 0; j &lt; n; j++)&#123;\n            dfs(p, 0, j);\n            dfs(a, m-1, j);\n        &#125;\n        for(int i &#x3D; 0; i &lt; m; i++)\n           for(int j &#x3D; 0; j &lt; n; j++)&#123;\n                &#x2F;&#x2F;能同时流入两个大洋的加入result\n                if(p[i][j] &amp;&amp; a[i][j])  \n                  result.push_back(&#123;i,j&#125;);\n            &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<p><strong>Comment:</strong></p>\n<p><strong>时间复杂度：O(mn), 每个单元格最多被遍历两次</strong></p>\n<p><strong>空间复杂度：O(mn)</strong></p>\n","feature":true,"text":"题目描述 Leetcode417-太平洋大西洋水流问题 有一个m x n的矩形岛屿，与 太平洋和大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。 这个岛被分割成一个由若干方形单元格组成的网格。给定一个m x n的整数矩阵*heigh...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF-DFS-%E5%8F%8D%E5%90%91\"><span class=\"toc-text\">思路: DFS(反向)</span></a></li></ol></li></ol>","author":{"name":"秦泽昊","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LRU缓存算法","uid":"3405a51be28fbdb1c58ecac6d40a5d4d","slug":"LRU缓存算法","date":"2023-07-04T07:30:07.000Z","updated":"2023-07-04T08:00:29.980Z","comments":true,"path":"api/articles/LRU缓存算法.json","keywords":null,"cover":null,"text":"LRU缓存 最近在做6.830 Lab2时涉及到了实现BufferPool中的eviction policy，即页面置换算法，简单来说，PageId与Page的映射关系为HashMap&lt;PageId, LinkedNode&gt; bufferPool，LinkedNode...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"秦泽昊","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Leetcode934_最短的桥","uid":"0611e9ed1fdeb61defdbe1f2f9a19cf6","slug":"Leetcode934-最短的桥","date":"2022-11-09T08:10:13.000Z","updated":"2022-12-17T15:08:02.653Z","comments":true,"path":"api/articles/Leetcode934-最短的桥.json","keywords":null,"cover":null,"text":"题目描述 Leetcode934-最短的桥 给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。 岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 你可以将任意数量的 0 变为 1 ，以使两...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"秦泽昊","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}