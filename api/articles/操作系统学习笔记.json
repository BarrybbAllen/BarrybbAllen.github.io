{"title":"操作系统学习笔记","uid":"495c8986559724f8c32aca1912ddb729","slug":"操作系统学习笔记","date":"2023-07-23T05:28:43.000Z","updated":"2023-07-29T11:23:36.220Z","comments":true,"path":"api/articles/操作系统学习笔记.json","keywords":null,"cover":[],"content":"<hr>\n<h1 id=\"第一章-概述\"><a href=\"#第一章-概述\" class=\"headerlink\" title=\"第一章 概述\"></a>第一章 概述</h1><img src=\"../images/OS/OS1.1.png\" style=\"zoom:40%;\" />\n\n<h3 id=\"1-1-操作系统的概念和功能：\"><a href=\"#1-1-操作系统的概念和功能：\" class=\"headerlink\" title=\"1.1 操作系统的概念和功能：\"></a>1.1 操作系统的概念和功能：</h3><ul>\n<li><p>是系统资源的管理者(<strong>管理整个计算机系统的硬件和软件资源</strong>)</p>\n</li>\n<li><p>向上层(<strong>用户和其他软件</strong>)提供接口和环境</p>\n</li>\n<li><p>最接近硬件的一层软件(<strong>硬件上的第一层软件，是对硬件系统的首次扩充</strong>)</p>\n</li>\n</ul>\n<img src=\"../images/OS/OS1.2.png\" style=\"zoom:100%;\" />\n\n\n\n<h3 id=\"1-2-操作系统的发展历程\"><a href=\"#1-2-操作系统的发展历程\" class=\"headerlink\" title=\"1.2 操作系统的发展历程\"></a>1.2 操作系统的发展历程</h3><img src=\"../images/OS/OS1.3.png\" style=\"zoom:75%;\" />\n\n\n\n<h3 id=\"1-3-操作系统的四大特征\"><a href=\"#1-3-操作系统的四大特征\" class=\"headerlink\" title=\"1.3 操作系统的四大特征\"></a>1.3 操作系统的四大特征</h3><h4 id=\"并发：\"><a href=\"#并发：\" class=\"headerlink\" title=\"并发：\"></a><strong>并发：</strong></h4><ul>\n<li><p>并发: 指两个或多个事件在同一时间<strong>间隔内发生</strong>，<strong>宏观上是同时发生的,但微观上是交替发生的</strong></p>\n</li>\n<li><p>并行: 指两个或多个事件在同一时刻<strong>同时发生</strong></p>\n</li>\n<li><p><strong>注意</strong>: 单核CPU<strong>同一时刻只能执行</strong>一个程序<strong>，各个程序只能</strong>并发<strong>地执行。</strong>多核CPU**同一时刻可以同时执行</p>\n<p><strong>多个程序</strong>，多个程序可以<strong>并行</strong>地执行</p>\n</li>\n</ul>\n<h4 id=\"共享：\"><a href=\"#共享：\" class=\"headerlink\" title=\"共享：\"></a><strong>共享：</strong></h4><ul>\n<li>资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</li>\n<li>互斥共享：同一个时间段只允许一个进程访问资源(摄像头/麦克风)</li>\n<li>同时共享：允许一个时间段多个进程“同时”(微观上是交替访问)访问某些资源，如硬盘读写</li>\n</ul>\n<h4 id=\"虚拟：\"><a href=\"#虚拟：\" class=\"headerlink\" title=\"虚拟：\"></a><strong>虚拟：</strong></h4><ul>\n<li><p>把一个物理上的实体变为若干个逻辑上的对应物，提升利用率。前者是实际存在的，后者是用户感受到的。</p>\n</li>\n<li><p>虚拟技术分为空分复用技术和时分复用技术。</p>\n</li>\n<li><p>空分复用技术(虚拟存储器)：物理4GB内存，用户看来远大于4GB</p>\n</li>\n<li><p>时分复用技术(虚拟处理器)：一个CPU看上去是几个CPU,多个程序并发运行</p>\n</li>\n</ul>\n<h4 id=\"异步：\"><a href=\"#异步：\" class=\"headerlink\" title=\"异步：\"></a><strong>异步：</strong></h4><ul>\n<li><p>在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的(需等待资源进程阻塞),</p>\n</li>\n<li><p>以不可预知的速度向前推进(进程的执行顺序和时间不确定)</p>\n</li>\n</ul>\n<p><strong>并发和共享</strong>是操作系统的两个最基本特征</p>\n<h3 id=\"1-4-操作系统的运行机制\"><a href=\"#1-4-操作系统的运行机制\" class=\"headerlink\" title=\"1.4 操作系统的运行机制\"></a>1.4 操作系统的运行机制</h3><ol>\n<li><p>指令：处理器(CPU)能识别和执行的最基本的命令(二进制机器指令)</p>\n</li>\n<li><p>两种指令：特权指令(如内存清零指令，只允许管理者使用)和非特权指令(如加减指令)</p>\n</li>\n<li><p>两种程序：应用程序和内核程序(组成操作系统内核，运行在内核态)</p>\n</li>\n<li><p>两种CPU状态：内核态(执行特权指令)和用户态(执行非特权指令)</p>\n</li>\n<li><p>补充：</p>\n</li>\n</ol>\n<p>​       程序状态寄存器(PSW)：1表示“内核态”，0表示“用户态”</p>\n<p>​       内核态→用户态：执行特权指令完成     用户态→内核态：由“中断引发”</p>\n<img src=\"../images/OS/OS1.4.png\" style=\"zoom:75%;\" />\n\n\n\n<h3 id=\"1-5-中断和异常\"><a href=\"#1-5-中断和异常\" class=\"headerlink\" title=\"1.5 中断和异常\"></a>1.5 中断和异常</h3><ol>\n<li><p>“中断”会使CPU由用户态变为内核态，是让操作系统内核夺回CPU使用权的唯一途径</p>\n</li>\n<li><p>中断的类型：</p>\n</li>\n</ol>\n<p>​       <img src=\"../images/OS/OS1.5.png\" style=\"zoom:90%;\" /></p>\n<ol start=\"3\">\n<li><p>中断机制的原理：不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中</p>\n<p>断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。(中断处理需要运行</p>\n<p>在“内核态”)</p>\n</li>\n<li><p>外中断的处理过程：</p>\n<p>Step 1: 执行完每个指令之后, CPU都要检查当前是否有外部中断信号 </p>\n<p>Step 2: 如果检测到外部中断信号,则需要保护被中断进程的CPU环境(如程序状态字Psw、程序计数器PC、各种通用寄存器) </p>\n<p>Step 3: 根据中断信号类型转入相应的中断处理程序(进入核心态) </p>\n<p>Step 4: 恢复原进程的CPU环境并退出中断,返回原进程继续往下执行</p>\n</li>\n</ol>\n<h3 id=\"1-6-系统调用：\"><a href=\"#1-6-系统调用：\" class=\"headerlink\" title=\"1.6 系统调用：\"></a>1.6 系统调用：</h3><ol>\n<li><p>概念：</p>\n<p>操作系统给应用程序提供的接口</p>\n<p>应用程序通过系统调用请求获得操作系统的服务</p>\n<p>系统调用使处理器进入核心态 ，是用户程序取得系统服务的唯一途径</p>\n</li>\n<li><p>系统调用和库函数的区别：</p>\n<img src=\"../images/OS/OS1.6.png\" style=\"zoom:80%;\" /></li>\n<li><p>系统调用的过程：</p>\n<img src=\"../images/OS/OS1.7.png\" style=\"zoom:80%;\" /></li>\n</ol>\n<ol start=\"4\">\n<li><p>需要使用系统调用的功能</p>\n<img src=\"../images/OS/OS1.8.png\" style=\"zoom:67%;\" /></li>\n</ol>\n<h3 id=\"1-7-操作系统的体系结构\"><a href=\"#1-7-操作系统的体系结构\" class=\"headerlink\" title=\"1.7 操作系统的体系结构\"></a>1.7 操作系统的体系结构</h3><ol>\n<li>内核</li>\n</ol>\n<img src=\"../images/OS/OS1.9.png\" style=\"zoom:60%;\" />\n\n<img src=\"../images/OS/OS1.10.png\" style=\"zoom:100%;\" />\n\n<p>​    注意：<br>​    操作系统内核需要运行在内核态<br>​    操作系统的非内核功能运行在用户态</p>\n<ol start=\"2\">\n<li><p>大内核与微内核比较</p>\n<img src=\"../images/OS/OS1.11.png\" style=\"zoom:75%;\" /></li>\n</ol>\n<p>​    典型的大内核/宏内核/单内核操作系统： Linux、UNIX<br>​    典型的微内核操作系统： Windows NT</p>\n<h3 id=\"1-8-操作系统引导和虚拟机\"><a href=\"#1-8-操作系统引导和虚拟机\" class=\"headerlink\" title=\"1.8 操作系统引导和虚拟机\"></a>1.8 操作系统引导和虚拟机</h3><p>以后有空整理</p>\n<hr>\n<h1 id=\"第二章-进程和线程\"><a href=\"#第二章-进程和线程\" class=\"headerlink\" title=\"第二章 进程和线程\"></a>第二章 进程和线程</h1><h3 id=\"2-1-进程的概念、组成、组织、特征\"><a href=\"#2-1-进程的概念、组成、组织、特征\" class=\"headerlink\" title=\"2.1 进程的概念、组成、组织、特征\"></a>2.1 进程的概念、组成、组织、特征</h3><h4 id=\"概念：\"><a href=\"#概念：\" class=\"headerlink\" title=\"概念：\"></a><strong>概念：</strong></h4><ul>\n<li><p>进程是程序的一次执行过程</p>\n</li>\n<li><p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</p>\n</li>\n<li><p>进程是具有独立功能的程序在数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位</p>\n</li>\n</ul>\n<h4 id=\"进程和程序的区别：\"><a href=\"#进程和程序的区别：\" class=\"headerlink\" title=\"进程和程序的区别：\"></a>进程和程序的区别：</h4><ul>\n<li><p>进程是动态的，程序是静态的</p>\n</li>\n<li><p>同一个程序多次执行会对应多个进程</p>\n</li>\n</ul>\n<h4 id=\"组成：\"><a href=\"#组成：\" class=\"headerlink\" title=\"组成：\"></a>组成：</h4><ul>\n<li><p>程序段：存放程序的代码(指令序列)</p>\n</li>\n<li><p>数据段：存放程序运行过程中处理的各种数据(如程序中定义的变量)</p>\n</li>\n<li><p>进程控制块PCB(Process Control Block)：程存在的唯一标志，对进程进行管理工作所需的信息都存在PCB中</p>\n<img src=\"../images/OS/OS2.1.png\" style=\"zoom:67%;\" /></li>\n<li><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）</p>\n</li>\n<li><p>引入进程实体的概念后，可把进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>\n</li>\n<li><p>同一个程序多次执行会对应不同的进程，它们的PCB、数据段各不相同，但程序段的内容都是相同的</p>\n</li>\n</ul>\n<h4 id=\"组织方式：\"><a href=\"#组织方式：\" class=\"headerlink\" title=\"组织方式：\"></a>组织方式：</h4><ul>\n<li>链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针</li>\n<li>索引方式：根据进程状态不同，建立索引表，操作系统持有指向各索引表的指针</li>\n</ul>\n<h4 id=\"特征：\"><a href=\"#特征：\" class=\"headerlink\" title=\"特征：\"></a>特征：</h4><img src=\"../images/OS/OS2.2.png\" style=\"zoom:100%;\" />\n\n\n\n<h3 id=\"2-2-进程的状态和转换\"><a href=\"#2-2-进程的状态和转换\" class=\"headerlink\" title=\"2.2 进程的状态和转换\"></a>2.2 进程的状态和转换</h3><h4 id=\"五个状态-三种基本状态：就绪、运行、阻塞-：\"><a href=\"#五个状态-三种基本状态：就绪、运行、阻塞-：\" class=\"headerlink\" title=\"五个状态(三种基本状态：就绪、运行、阻塞)：\"></a>五个状态(三种基本状态：就绪、运行、阻塞)：</h4><ul>\n<li>运行态(Running)：占有CPU，并在CPU上运行</li>\n<li>就绪态(Ready)：进程已经具备运行条件，由于没有空闲CPU，导致暂时不能运行</li>\n<li>阻塞态(Waiting/Blocked)：等待某一事件而暂时不能运行，如等待操作系统分配打印机、等待磁盘读写等</li>\n<li>创建态(New)：操作系统为该进程分配所需内存等系统资源，并初始化PCB(分配PID等等)</li>\n<li>终止态(Terminated)：进程运行结束或无法继续执行，操作系统需要回收进程资源，撤销PCB</li>\n</ul>\n<h4 id=\"进程间的状态转换：\"><a href=\"#进程间的状态转换：\" class=\"headerlink\" title=\"进程间的状态转换：\"></a>进程间的状态转换：</h4><img src=\"../images/OS/OS2.3.png\" style=\"zoom:90%;\" />\n\n\n\n<h3 id=\"2-3-进程的控制\"><a href=\"#2-3-进程的控制\" class=\"headerlink\" title=\"2.3 进程的控制\"></a>2.3 进程的控制</h3><h4 id=\"原语：\"><a href=\"#原语：\" class=\"headerlink\" title=\"原语：\"></a>原语：</h4><ul>\n<li>进程控制就是要实现进程状态的转换</li>\n<li>实现：通过“原语”实现，“原语”是一种特殊的程序，它的执行具有原子性。也就是说这段程序的<br>运行不能中断</li>\n<li>CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</li>\n<li>原语的实现：通过“关中断指令”和“开中断指令”这两个特权指令(运行在核心态)，CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。</li>\n</ul>\n<h4 id=\"进程控制相关的原语：\"><a href=\"#进程控制相关的原语：\" class=\"headerlink\" title=\"进程控制相关的原语：\"></a>进程控制相关的原语：</h4><ul>\n<li><p>创建原语 撤销原语 阻塞原语 唤醒原语 切换原语</p>\n</li>\n<li><p>进程的阻塞和唤醒原语是成对存在的，因何事阻塞，就应由何事唤醒</p>\n</li>\n<li><p>原语的共同点：</p>\n<ol>\n<li>更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)    </li>\n</ol>\n<p>​        a. 所有的进程控制原语一定都会修改进程状态标志    </p>\n<p>​        b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境    </p>\n<p>​        c. 某进程开始运行前必然要恢复期运行环境</p>\n<ol start=\"2\">\n<li><p>将PCB插入合适的队列 </p>\n</li>\n<li><p>分配和回收资源</p>\n</li>\n</ol>\n</li>\n</ul>\n<img src=\"../images/OS/OS2.4.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"2-4-进程通信：\"><a href=\"#2-4-进程通信：\" class=\"headerlink\" title=\"2.4 进程通信：\"></a>2.4 进程通信：</h3><h4 id=\"概念：-1\"><a href=\"#概念：-1\" class=\"headerlink\" title=\"概念：\"></a>概念：</h4><ul>\n<li><p>进程通信指进程之间的信息交换</p>\n</li>\n<li><p>各进程拥有相互独立的内存地址空间，一个进程不能直接访问另一个进程的地址空间</p>\n</li>\n</ul>\n<h4 id=\"三种通信方式：共享存储、消息传递、管道通信\"><a href=\"#三种通信方式：共享存储、消息传递、管道通信\" class=\"headerlink\" title=\"三种通信方式：共享存储、消息传递、管道通信\"></a>三种通信方式：共享存储、消息传递、管道通信</h4><ul>\n<li><p>共享存储</p>\n<img src=\"../images/OS/OS2.5.png\" style=\"zoom:80%;\" /></li>\n<li><p>消息传递</p>\n<img src=\"../images/OS/OS2.7.png\" style=\"zoom:80%;\" /></li>\n<li><p>管道通信：</p>\n<img src=\"../images/OS/OS2.6.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><img src=\"../images/OS/OS2.8.png\" style=\"zoom:70%;\" />\n\n\n\n<h3 id=\"2-5-线程基础\"><a href=\"#2-5-线程基础\" class=\"headerlink\" title=\"2.5 线程基础\"></a>2.5 线程基础</h3><h4 id=\"概念：-2\"><a href=\"#概念：-2\" class=\"headerlink\" title=\"概念：\"></a>概念：</h4><ul>\n<li><p>可以理解为“轻量级进程”，是基本的CPU执行单元，也是程序执行流的最小单位</p>\n</li>\n<li><p>线程的引入可增加并发度，减少并发带来的开销</p>\n<img src=\"../images/OS/OS2.9.png\" style=\"zoom:50%;\" /></li>\n</ul>\n<h4 id=\"线程的特点：\"><a href=\"#线程的特点：\" class=\"headerlink\" title=\"线程的特点：\"></a>线程的特点：</h4><ul>\n<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>\n<li>同一进程的各线程共享进程拥有的资源</li>\n<li>同一进程内的线程切换，不需要切换进程坏境，系统开销小</li>\n</ul>\n<h4 id=\"线程的属性：\"><a href=\"#线程的属性：\" class=\"headerlink\" title=\"线程的属性：\"></a>线程的属性：</h4><img src=\"../images/OS/OS2.10.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"2-6-线程的实现方式和多线程模型\"><a href=\"#2-6-线程的实现方式和多线程模型\" class=\"headerlink\" title=\"2.6 线程的实现方式和多线程模型\"></a>2.6 线程的实现方式和多线程模型</h3><h4 id=\"实现方式：\"><a href=\"#实现方式：\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h4><p>分为用户级线程(User-Level Thread, ULT)和内核级线程(Kernel-Level Thread, KLT)</p>\n<img src=\"../images/OS/OS2.11.png\" style=\"zoom:60%;\" />\n\n\n\n<img src=\"../images/OS/OS2.12.png\" style=\"zoom:60%;\" />\n\n\n\n<h4 id=\"多线程模型：\"><a href=\"#多线程模型：\" class=\"headerlink\" title=\"多线程模型：\"></a>多线程模型：</h4><ul>\n<li><p>一对一模型：</p>\n<img src=\"../images/OS/OS2.13.png\" style=\"zoom:60%;\" /></li>\n<li><p>多对一模型：</p>\n<img src=\"../images/OS/OS2.14.png\" style=\"zoom:50%;\" /></li>\n<li><p>多对多模型：</p>\n<img src=\"../images/OS/OS2.15.png\" style=\"zoom:55%;\" /></li>\n</ul>\n<p><strong>注意：</strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p>\n<h3 id=\"2-7-线程的状态与控制\"><a href=\"#2-7-线程的状态与控制\" class=\"headerlink\" title=\"2.7 线程的状态与控制\"></a>2.7 线程的状态与控制</h3><ul>\n<li><p>状态与转换</p>\n<img src=\"../images/OS/OS2.16.png\" style=\"zoom:40%;\" /></li>\n<li><p>组织与控制</p>\n<img src=\"../images/OS/OS2.17.png\" style=\"zoom:50%;\" /></li>\n</ul>\n<hr>\n<h1 id=\"第三章-处理机调度\"><a href=\"#第三章-处理机调度\" class=\"headerlink\" title=\"第三章 处理机调度\"></a>第三章 处理机调度</h1><h3 id=\"3-1-调度的概念和层次\"><a href=\"#3-1-调度的概念和层次\" class=\"headerlink\" title=\"3.1 调度的概念和层次\"></a>3.1 调度的概念和层次</h3><h4 id=\"概念：-3\"><a href=\"#概念：-3\" class=\"headerlink\" title=\"概念：\"></a>概念：</h4><p>从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p>\n<h4 id=\"调度的层次：\"><a href=\"#调度的层次：\" class=\"headerlink\" title=\"调度的层次：\"></a>调度的层次：</h4><ul>\n<li><p>高级调度(作业调度)：</p>\n<img src=\"../images/OS/OS3.1.png\" style=\"zoom:60%;\" /></li>\n<li><p>中级调度(内存调度)：</p>\n<img src=\"../images/OS/OS3.2.png\" style=\"zoom:60%;\" /></li>\n<li><p>低级调度(进程调度)</p>\n<img src=\"../images/OS/OS3.3.png\" style=\"zoom:60%;\" /></li>\n</ul>\n<h4 id=\"七状态模型：\"><a href=\"#七状态模型：\" class=\"headerlink\" title=\"七状态模型：\"></a>七状态模型：</h4><img src=\"../images/OS/OS3.4.png\" style=\"zoom:60%;\" />\n\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><img src=\"../images/OS/OS3.5.png\" style=\"zoom:70%;\" />\n\n\n\n<h3 id=\"3-2-进程调度的时机-主动-被动放弃-、切换与过程-广义-狭义-、方式-非剥夺-剥夺\"><a href=\"#3-2-进程调度的时机-主动-被动放弃-、切换与过程-广义-狭义-、方式-非剥夺-剥夺\" class=\"headerlink\" title=\"3.2 进程调度的时机(主动/被动放弃)、切换与过程(广义/狭义)、方式(非剥夺/剥夺)\"></a>3.2 进程调度的时机(主动/被动放弃)、切换与过程(广义/狭义)、方式(非剥夺/剥夺)</h3><img src=\"../images/OS/OS3.6.png\" style=\"zoom:80%;\" />\n\n<p>注意：</p>\n<ul>\n<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程</li>\n<li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</li>\n<li>广义的进程调度包含了选择一个进程和进程切换两个步骤</li>\n<li>非剥夺调度方式(非抢占式)实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li>\n</ul>\n<h3 id=\"3-3-调度程序-scheduler\"><a href=\"#3-3-调度程序-scheduler\" class=\"headerlink\" title=\"3.3 调度程序(scheduler)\"></a>3.3 调度程序(scheduler)</h3><ul>\n<li><p>调度程序：</p>\n<p>作用：完成从就绪态→运行态和运行态→就绪态</p>\n<p>时机：创建新进程、进程退出、进程阻塞、I/O中断发生等</p>\n</li>\n<li><p>闲逛进程：</p>\n<p>没有其他任何就绪进程时，就会运行闲逛进程(idle)</p>\n<p>特点：优先级最低；可以是0地址指令，占一个完整的指令周期；能熬低</p>\n</li>\n</ul>\n<h3 id=\"3-4-调度算法的评价指标\"><a href=\"#3-4-调度算法的评价指标\" class=\"headerlink\" title=\"3. 4 调度算法的评价指标\"></a>3. 4 调度算法的评价指标</h3><img src=\"../images/OS/OS3.7.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"3-5-调度算法一-早期批处理系统\"><a href=\"#3-5-调度算法一-早期批处理系统\" class=\"headerlink\" title=\"3.5 调度算法一(早期批处理系统)\"></a>3.5 调度算法一(早期批处理系统)</h3><h4 id=\"先来先服务FCFS-First-Come-First-Serve\"><a href=\"#先来先服务FCFS-First-Come-First-Serve\" class=\"headerlink\" title=\"先来先服务FCFS(First Come First Serve)\"></a>先来先服务FCFS(First Come First Serve)</h4><ul>\n<li>规则：公平角度考虑，作业/进程谁先到后备队列的谁先得到服务，是非抢占式算法 </li>\n<li>优点：公平，算法简单 ，不会导致饥饿</li>\n<li>缺点：对长作业/进程有利，对短作业不利(带权周转时间大)，</li>\n</ul>\n<h4 id=\"短作业优先SJF-Shortest-Job-First\"><a href=\"#短作业优先SJF-Shortest-Job-First\" class=\"headerlink\" title=\"短作业优先SJF(Shortest Job First)\"></a>短作业优先SJF(Shortest Job First)</h4><ul>\n<li>思想：追求最少的平均等待时间，最少平均周转时间，最少平均带权周转时间 </li>\n<li>规则：需要服务时间最短的作业/进程优先得到服务(用于进程调度时称为“短进程优先SPF(Shortest Process First)”算法） </li>\n<li>SJF和SPF是非抢占式算法，抢占式版本：最短剩余时间优先算法SRTN(Shortest Remaining Time Next)</li>\n<li>优点：“最短的”平均等待时间、平均周转时间 </li>\n<li>缺点：不公平，对短作业有利，长作业不利；可能导致饥饿，如果有源源不断的短作业到来，长作业可能一直得不到服务（饿死）</li>\n</ul>\n<img src=\"../images/OS/OS3.8.png\" style=\"zoom:70%;\" />\n\n<p>​       <img src=\"../images/OS/OS3.9.png\" style=\"zoom:70%;\" /></p>\n<img src=\"../images/OS/OS3.10.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"高响应比优先HRRN-Highest-Response-Ratio-Next\"><a href=\"#高响应比优先HRRN-Highest-Response-Ratio-Next\" class=\"headerlink\" title=\"高响应比优先HRRN(Highest Response Ratio Next)\"></a>高响应比优先HRRN(Highest Response Ratio Next)</h4><ul>\n<li>思想：综合考虑作业/进程的等待时间和服务时间，是FCFS和SJF的折衷 </li>\n<li>规则：每次调度时选择响应比最高的作业/进程服务，响应比=(等待时间+要求服务时间)/要求服务时间，</li>\n<li>特点：是非抢占式算法，只有当前作业/进程主动放弃处理机，才需要调度和计算响应比 </li>\n<li>优点：综合考虑了等待时间和运行时间(要求服务时间)，不会导致饥饿</li>\n</ul>\n<img src=\"../images/OS/OS3.11.png\" style=\"zoom:70%;\" />\n\n\n\n<h3 id=\"3-6-调度算法二-交互式系统算法\"><a href=\"#3-6-调度算法二-交互式系统算法\" class=\"headerlink\" title=\"3.6 调度算法二(交互式系统算法)\"></a>3.6 调度算法二(交互式系统算法)</h3><h4 id=\"时间片轮转RR-Round-Robin\"><a href=\"#时间片轮转RR-Round-Robin\" class=\"headerlink\" title=\"时间片轮转RR(Round-Robin)\"></a>时间片轮转RR(Round-Robin)</h4><ul>\n<li>思想：公平、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应 </li>\n<li>规则：按照各进程到达就绪队列的顺序,轮流让各个进程执行一个相同的时间片 。若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队。 </li>\n<li>特点：用于进程调度（作业在建立相应进程后才能被分配处理机时间片)；是抢占式算法，由时钟中断通知CPU时间片已到，不会发生饥饿 </li>\n<li>优点：公平，响应快，适用于分时操作系统</li>\n<li>缺点：高频率进程切换，有一定的开销，不区分任务的紧急程度</li>\n</ul>\n<p>注意：</p>\n<ol>\n<li>时间片太长，可能会退化为FCFS算法</li>\n<li>时间片太短，会导致进程切换过于频繁，增大系统开销</li>\n</ol>\n<h4 id=\"优先级调度算法\"><a href=\"#优先级调度算法\" class=\"headerlink\" title=\"优先级调度算法\"></a>优先级调度算法</h4><ul>\n<li>思想：调度时选择优先级高的作业/进程</li>\n<li>既可以用于作业调度，也可以用于进程调度，抢占/非抢占式都有，</li>\n<li>优点：优先级区分紧急程度，适用于实时操作系统</li>\n<li>缺点：若高优先级进程过多，可能导致饥饿</li>\n</ul>\n<h4 id=\"多级反馈队列调度算法\"><a href=\"#多级反馈队列调度算法\" class=\"headerlink\" title=\"多级反馈队列调度算法\"></a>多级反馈队列调度算法</h4><ul>\n<li>思想：对其他各种调度算法的权衡</li>\n<li>特点：设置多个就绪队列，每个队列使用不同优先级。能够在不知道进程时长的情况下满足各类型用户的需要</li>\n</ul>\n<p>​                   第1至第n-1级队列：FCFS</p>\n<p>​                   第n级队列：RR</p>\n<ul>\n<li><p>缺点：仍然可能导致饥饿</p>\n<img src=\"../images/OS/OS3.12.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<hr>\n<h1 id=\"第四章-进程的同步与互斥\"><a href=\"#第四章-进程的同步与互斥\" class=\"headerlink\" title=\"第四章 进程的同步与互斥\"></a>第四章 进程的同步与互斥</h1><h3 id=\"4-1-基本概念\"><a href=\"#4-1-基本概念\" class=\"headerlink\" title=\"4.1 基本概念\"></a>4.1 基本概念</h3><p>进程的异步性：各并发执行的进程以各自独立的、不可预知的速度推进</p>\n<p>进程的同步性：为了完成某种任务而建立两个或多个进程，这些进程因为需要在某些位置上协调工作次序而产生的制约关系，如等待、传递信息等。进程同步也称为直接制约关系，是为了解决进程的异步问题。</p>\n<p>进程的互斥：一个进程访问某些临界资源时，另一个想要访问该临界资源的进程必需等待，直到资源被释放</p>\n<p>临界资源：一个时间段内只允许一个进程使用的资源（比如一些物理设备，变量数据，内存缓冲区）</p>\n<h3 id=\"4-2-对临界资源的互斥访问\"><a href=\"#4-2-对临界资源的互斥访问\" class=\"headerlink\" title=\"4.2 对临界资源的互斥访问\"></a>4.2 对临界资源的互斥访问</h3><h4 id=\"四个部分：\"><a href=\"#四个部分：\" class=\"headerlink\" title=\"四个部分：\"></a>四个部分：</h4><ul>\n<li>进入区：负责检查是否可以进入临界区的代码，若可以进入则设置“正在访问临界资源的标志”（上锁），阻止其它进程同时进入临界区</li>\n<li>临界区：又叫临界段，是负责访问临界资源的代码</li>\n<li>退出区：负责解除“正在访问临界资源的标志”（解锁）的代码</li>\n<li>剩余区：做其他处理</li>\n</ul>\n<h4 id=\"遵守原则：\"><a href=\"#遵守原则：\" class=\"headerlink\" title=\"遵守原则：\"></a>遵守原则：</h4><ul>\n<li>空闲让进：临界区空闲，应允许一个进程访问</li>\n<li>忙则等待：临界区正在被访问时，其它试图访问的进程需要等待</li>\n<li>有限等待：对请求访问的进程，应在有限的时间内进入临界区(保证不会饥饿)</li>\n<li>让权等待：进不了临界区的进程，释放处理机，防止忙等待</li>\n</ul>\n<h3 id=\"4-3-进程互斥的软件实现方法\"><a href=\"#4-3-进程互斥的软件实现方法\" class=\"headerlink\" title=\"4.3 进程互斥的软件实现方法\"></a>4.3 进程互斥的软件实现方法</h3><p>软件实现方法的思想：在进入区设置并检查一些标志 ，来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>\n<ul>\n<li><p>单标志法：</p>\n<img src=\"../images/OS/OS4.1.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<ul>\n<li><p>双标志先检查法：</p>\n<img src=\"../images/OS/OS4.2.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<ul>\n<li><p>双标志后检查法：</p>\n<img src=\"../images/OS/OS4.3.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<ul>\n<li><p>Peterson算法：</p>\n<img src=\"../images/OS/OS4.4.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<p>总结：</p>\n<img src=\"../images/OS/OS4.8.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"4-4-进程互斥的硬件实现方法\"><a href=\"#4-4-进程互斥的硬件实现方法\" class=\"headerlink\" title=\"4.4 进程互斥的硬件实现方法\"></a>4.4 进程互斥的硬件实现方法</h3><ul>\n<li><p>中断屏蔽法：</p>\n<img src=\"../images/OS/OS4.5.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<ul>\n<li><p>TestAndSet指令</p>\n<img src=\"../images/OS/OS4.6.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<ul>\n<li><p>Swap指令</p>\n<img src=\"../images/OS/OS4.7.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<p>总结：</p>\n<img src=\"../images/OS/OS4.9.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"4-5-互斥锁：\"><a href=\"#4-5-互斥锁：\" class=\"headerlink\" title=\"4.5 互斥锁：\"></a>4.5 互斥锁：</h3><h3 id=\"4-6-信号量机制：\"><a href=\"#4-6-信号量机制：\" class=\"headerlink\" title=\"4.6 信号量机制：\"></a>4.6 信号量机制：</h3><h4 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h4><p>进程互斥的软硬件实现方式都无法解决“让权等待”问题</p>\n<p>1965年，荷兰学者Dijkstra提出了一种实现进程互斥、同步的方法 ——信号量机制</p>\n<h4 id=\"基本概念和术语：\"><a href=\"#基本概念和术语：\" class=\"headerlink\" title=\"基本概念和术语：\"></a>基本概念和术语：</h4><ol>\n<li>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作,从而很方便的实现了进程互斥、进程同步</li>\n<li>信号量其实就是一个变量(可以是 个整数,也可以是更复杂的记录型变量),可以用一个信号量来表示系统中某种资源的数量,比如:系统中只有一台打印机,就可以设置一个初值为1的信号量 </li>\n<li>原语是一种特殊的程序段,其执行只能一气呵成,不可被中断。原语是由关中断/开中断指令实现的</li>\n<li>软件解决方案的主要问题是由“进入区的各种操作无法一气呵成” ,因此如果能把进入区、退出区的操作都用“原语”实现,使这些操作能“一气呵成”就能避免问题。</li>\n<li> wait(S)原语和signal(S)原语,可以理解为函数(函数名分别为wait和signal,S就是参数)，wait, signal原语常简称为P,V操作(来自荷兰语检测proberen和增加verhogen) 。因此,常把wait(S).signal(S)两个操作分别写为P(S)、V(S)</li>\n<li>信号量可分为整型信号量和记录型信号量</li>\n</ol>\n<h4 id=\"整型信号量：\"><a href=\"#整型信号量：\" class=\"headerlink\" title=\"整型信号量：\"></a>整型信号量：</h4><img src=\"../images/OS/OS4.10.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"记录型信号量：\"><a href=\"#记录型信号量：\" class=\"headerlink\" title=\"记录型信号量：\"></a>记录型信号量：</h4><img src=\"../images/OS/OS4.11.png\" style=\"zoom:70%;\" />\n\n\n\n<h3 id=\"4-7-信号量机制实现进程的互斥、同步与前驱关系\"><a href=\"#4-7-信号量机制实现进程的互斥、同步与前驱关系\" class=\"headerlink\" title=\"4.7 信号量机制实现进程的互斥、同步与前驱关系\"></a>4.7 信号量机制实现进程的互斥、同步与前驱关系</h3><h4 id=\"实现进程互斥：\"><a href=\"#实现进程互斥：\" class=\"headerlink\" title=\"实现进程互斥：\"></a>实现进程互斥：</h4><img src=\"../images/OS/OS4.12.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"实现进程同步：\"><a href=\"#实现进程同步：\" class=\"headerlink\" title=\"实现进程同步：\"></a>实现进程同步：</h4><img src=\"../images/OS/OS4.13.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"实现前驱关系：\"><a href=\"#实现前驱关系：\" class=\"headerlink\" title=\"实现前驱关系：\"></a>实现前驱关系：</h4><img src=\"../images/OS/OS4.14.png\" style=\"zoom:70%;\" />\n\n\n\n<h3 id=\"4-8-进程同步与互斥经典问题\"><a href=\"#4-8-进程同步与互斥经典问题\" class=\"headerlink\" title=\"4.8 进程同步与互斥经典问题\"></a>4.8 进程同步与互斥经典问题</h3><h4 id=\"1-生产者-—-消费者问题\"><a href=\"#1-生产者-—-消费者问题\" class=\"headerlink\" title=\"1. 生产者 — 消费者问题\"></a>1. 生产者 — 消费者问题</h4><ul>\n<li>分析：</li>\n</ul>\n<img src=\"../images/OS/OS4.16.png\" style=\"zoom:70%;\" />\n\n<ul>\n<li>实现：</li>\n</ul>\n<img src=\"../images/OS/OS4.17.png\" style=\"zoom:70%;\" />\n\n<ul>\n<li>为什么实现互斥的P操作一定要在实现同步的P操作之后</li>\n</ul>\n<img src=\"../images/OS/OS4.18.png\" style=\"zoom:70%;\" />\n","feature":true,"text":" 第一章 概述 1.1 操作系统的概念和功能： 是系统资源的管理者(管理整个计算机系统的硬件和软件资源) 向上层(用户和其他软件)提供接口和环境 最接近硬件的一层软件(硬件上的第一层软件，是对硬件系统的首次扩充) 1.2 操作系统的发展历程 1.3 操作系统的四大特征并发： 并发...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">第一章 概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8A%9F%E8%83%BD%EF%BC%9A\"><span class=\"toc-text\">1.1 操作系统的概念和功能：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B\"><span class=\"toc-text\">1.2 操作系统的发展历程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">1.3 操作系统的四大特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%EF%BC%9A\"><span class=\"toc-text\">并发：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B1%E4%BA%AB%EF%BC%9A\"><span class=\"toc-text\">共享：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%EF%BC%9A\"><span class=\"toc-text\">虚拟：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%EF%BC%9A\"><span class=\"toc-text\">异步：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">1.4 操作系统的运行机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">1.5 中断和异常</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">1.6 系统调用：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.7 操作系统的体系结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-8-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">1.8 操作系统引导和虚拟机</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">第二章 进程和线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%BB%84%E7%BB%87%E3%80%81%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">2.1 进程的概念、组成、组织、特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">概念：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">进程和程序的区别：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E6%88%90%EF%BC%9A\"><span class=\"toc-text\">组成：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">组织方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E5%BE%81%EF%BC%9A\"><span class=\"toc-text\">特征：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">2.2 进程的状态和转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81-%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9A%E5%B0%B1%E7%BB%AA%E3%80%81%E8%BF%90%E8%A1%8C%E3%80%81%E9%98%BB%E5%A1%9E-%EF%BC%9A\"><span class=\"toc-text\">五个状态(三种基本状态：就绪、运行、阻塞)：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%9A\"><span class=\"toc-text\">进程间的状态转换：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">2.3 进程的控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E8%AF%AD%EF%BC%9A\"><span class=\"toc-text\">原语：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8E%9F%E8%AF%AD%EF%BC%9A\"><span class=\"toc-text\">进程控制相关的原语：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A\"><span class=\"toc-text\">2.4 进程通信：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5%EF%BC%9A-1\"><span class=\"toc-text\">概念：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E3%80%81%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E3%80%81%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">三种通信方式：共享存储、消息传递、管道通信</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">2.5 线程基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5%EF%BC%9A-2\"><span class=\"toc-text\">概念：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">线程的特点：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A\"><span class=\"toc-text\">线程的属性：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.6 线程的实现方式和多线程模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">实现方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">多线程模型：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">2.7 线程的状态与控制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">第三章 处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1\"><span class=\"toc-text\">3.1 调度的概念和层次</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5%EF%BC%9A-3\"><span class=\"toc-text\">概念：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%EF%BC%9A\"><span class=\"toc-text\">调度的层次：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">七状态模型：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A-1\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA-%E4%B8%BB%E5%8A%A8-%E8%A2%AB%E5%8A%A8%E6%94%BE%E5%BC%83-%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B-%E5%B9%BF%E4%B9%89-%E7%8B%AD%E4%B9%89-%E3%80%81%E6%96%B9%E5%BC%8F-%E9%9D%9E%E5%89%A5%E5%A4%BA-%E5%89%A5%E5%A4%BA\"><span class=\"toc-text\">3.2 进程调度的时机(主动&#x2F;被动放弃)、切换与过程(广义&#x2F;狭义)、方式(非剥夺&#x2F;剥夺)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F-scheduler\"><span class=\"toc-text\">3.3 调度程序(scheduler)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87\"><span class=\"toc-text\">3. 4 调度算法的评价指标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%B8%80-%E6%97%A9%E6%9C%9F%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">3.5 调度算法一(早期批处理系统)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1FCFS-First-Come-First-Serve\"><span class=\"toc-text\">先来先服务FCFS(First Come First Serve)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88SJF-Shortest-Job-First\"><span class=\"toc-text\">短作业优先SJF(Shortest Job First)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88HRRN-Highest-Response-Ratio-Next\"><span class=\"toc-text\">高响应比优先HRRN(Highest Response Ratio Next)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BA%8C-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.6 调度算法二(交互式系统算法)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%ACRR-Round-Robin\"><span class=\"toc-text\">时间片轮转RR(Round-Robin)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">优先级调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">多级反馈队列调度算法</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5\"><span class=\"toc-text\">第四章 进程的同步与互斥</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4.1 基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%AF%B9%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">4.2 对临界资源的互斥访问</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9A\"><span class=\"toc-text\">四个部分：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%B5%E5%AE%88%E5%8E%9F%E5%88%99%EF%BC%9A\"><span class=\"toc-text\">遵守原则：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.3 进程互斥的软件实现方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.4 进程互斥的硬件实现方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">4.5 互斥锁：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%EF%BC%9A\"><span class=\"toc-text\">4.6 信号量机制：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF%EF%BC%9A\"><span class=\"toc-text\">背景：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD%EF%BC%9A\"><span class=\"toc-text\">基本概念和术语：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9A\"><span class=\"toc-text\">整型信号量：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%9A\"><span class=\"toc-text\">记录型信号量：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">4.7 信号量机制实现进程的互斥、同步与前驱关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%9A\"><span class=\"toc-text\">实现进程互斥：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A\"><span class=\"toc-text\">实现进程同步：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB%EF%BC%9A\"><span class=\"toc-text\">实现前驱关系：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4.8 进程同步与互斥经典问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%94%9F%E4%BA%A7%E8%80%85-%E2%80%94-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 生产者 — 消费者问题</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"计算机网络学习笔记","uid":"857b99bbc17d9cdd5bc19bc9d8890bad","slug":"计算机网络学习笔记","date":"2023-07-11T07:17:04.000Z","updated":"2023-07-29T11:02:23.329Z","comments":true,"path":"api/articles/计算机网络学习笔记.json","keywords":null,"cover":[],"text":"第一章 概述1.1 网络、互联网和因特网网络：网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。 互联网：多个网络通过路由器互连起来，构成了一个覆盖范围更大的网络，即互联网（互连网）。因此，互联网又称为“网络的网络（Network of Netwo...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"}],"author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}