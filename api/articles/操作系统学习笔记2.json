{"title":"操作系统学习笔记2","uid":"de035ae06e7a658a87102027ae8a8a7e","slug":"操作系统学习笔记2","date":"2023-07-29T11:46:28.000Z","updated":"2023-08-02T12:25:33.079Z","comments":true,"path":"api/articles/操作系统学习笔记2.json","keywords":null,"cover":[],"content":"<h1 id=\"第五章-死锁\"><a href=\"#第五章-死锁\" class=\"headerlink\" title=\"第五章 死锁\"></a>第五章 死锁</h1><h3 id=\"5-1-死锁基本概念\"><a href=\"#5-1-死锁基本概念\" class=\"headerlink\" title=\"5.1 死锁基本概念\"></a>5.1 死锁基本概念</h3><h4 id=\"死锁：\"><a href=\"#死锁：\" class=\"headerlink\" title=\"死锁：\"></a>死锁：</h4><p>并发环境下，各进程因为竞争资源造成的互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>\n<p>除对系统资源的竞争外，进程推进非法和信号量使用不当等情况也会造成死锁</p>\n<h4 id=\"死锁、饥饿和死循环\"><a href=\"#死锁、饥饿和死循环\" class=\"headerlink\" title=\"死锁、饥饿和死循环\"></a>死锁、饥饿和死循环</h4><img src=\"../images/OS/OS5.1.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"死锁产生的条件：\"><a href=\"#死锁产生的条件：\" class=\"headerlink\" title=\"死锁产生的条件：\"></a>死锁产生的条件：</h4><ul>\n<li><p>互斥条件：争抢必须互斥使用的资源</p>\n</li>\n<li><p>不剥夺条件：进程获得的资源未使用完成，其它进程不能强行夺走，只能等待主动释放</p>\n</li>\n<li><p>请求和保持条件：进程已经保持了至少一个资源，但是又提出新的资源请求，同时该资源被其它进程占有<br>此时请求进程被阻塞，但是对自己拥有资源又保持不放</p>\n</li>\n<li><p>循环等待条件：死锁时存在循环等待链，但是存在循环等待链不一定出现死锁</p>\n</li>\n</ul>\n<h4 id=\"死锁的处理策略：\"><a href=\"#死锁的处理策略：\" class=\"headerlink\" title=\"死锁的处理策略：\"></a>死锁的处理策略：</h4><ul>\n<li><p>预防死锁：破坏产生死锁的条件(四个条件中的一个或几个)</p>\n</li>\n<li><p>避免死锁：避免系统进入不安全状态（银行家算法）</p>\n</li>\n<li><p>检测和解除：允许死锁发生，操作系统负责检测死锁并解除</p>\n</li>\n</ul>\n<h3 id=\"5-2-死锁的处理-——-预防死锁\"><a href=\"#5-2-死锁的处理-——-预防死锁\" class=\"headerlink\" title=\"5.2 死锁的处理 —— 预防死锁\"></a>5.2 死锁的处理 —— 预防死锁</h3><img src=\"../images/OS/OS5.6.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"5-3-死锁的处理-——-避免死锁\"><a href=\"#5-3-死锁的处理-——-避免死锁\" class=\"headerlink\" title=\"5.3 死锁的处理 —— 避免死锁\"></a>5.3 死锁的处理 —— 避免死锁</h3><h4 id=\"安全序列与安全状态：\"><a href=\"#安全序列与安全状态：\" class=\"headerlink\" title=\"安全序列与安全状态：\"></a>安全序列与安全状态：</h4><ul>\n<li>安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成</li>\n<li>只要能找出一个安全序列，整个系统就是安全状态，一定不会发生死锁</li>\n<li>安全序列可能有多个</li>\n<li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态，可能发生死锁</li>\n</ul>\n<h4 id=\"银行家算法：\"><a href=\"#银行家算法：\" class=\"headerlink\" title=\"银行家算法：\"></a>银行家算法：</h4><p>背景：                                                                                                                                                                                       由荷兰学者 Dijkstra 最早为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁</p>\n<p>思想：                                                                                                                                                                                  在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>\n<p>实现：</p>\n<img src=\"../images/OS/OS5.3.png\" style=\"zoom:75%;\" />\n\n<p>银行家算法的不足：对资源分配相对保守，计算多，需要预知未来进程变化和资源请求</p>\n<h3 id=\"5-4-死锁的处理-——-死锁的检测和解除\"><a href=\"#5-4-死锁的处理-——-死锁的检测和解除\" class=\"headerlink\" title=\"5.4 死锁的处理 —— 死锁的检测和解除\"></a>5.4 死锁的处理 —— 死锁的检测和解除</h3><h4 id=\"死锁检测：\"><a href=\"#死锁检测：\" class=\"headerlink\" title=\"死锁检测：\"></a>死锁检测：</h4><img src=\"../images/OS/OS5.4.png\" style=\"zoom:70%;\" />\n\n<h4 id=\"死锁解除：\"><a href=\"#死锁解除：\" class=\"headerlink\" title=\"死锁解除：\"></a>死锁解除：</h4><img src=\"../images/OS/OS5.5.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><img src=\"../images/OS/OS5.7.png\" style=\"zoom:80%;\" />\n\n<hr>\n<h1 id=\"第六章-内存管理\"><a href=\"#第六章-内存管理\" class=\"headerlink\" title=\"第六章 内存管理\"></a>第六章 内存管理</h1><h3 id=\"6-1-内存基础\"><a href=\"#6-1-内存基础\" class=\"headerlink\" title=\"6.1 内存基础\"></a>6.1 内存基础</h3><h4 id=\"内存相关概念：\"><a href=\"#内存相关概念：\" class=\"headerlink\" title=\"内存相关概念：\"></a>内存相关概念：</h4><ul>\n<li>由一个一个可存放数据的存储单元构成</li>\n<li>程序执行前需要先放到内存中才能被CPU处理 —— 缓和CPU与硬盘之间的速度矛盾</li>\n<li>存储单元：<ul>\n<li>按字节编址：一个存储单元指1字节，8个二进制位 </li>\n<li>按字长编址：一个存储单元1个字长，字长16位的计算机一个存储单元16个二进制位</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"指令的工作原理：\"><a href=\"#指令的工作原理：\" class=\"headerlink\" title=\"指令的工作原理：\"></a>指令的工作原理：</h4><ul>\n<li>CPU按照程序段的指令去内存某个位置存取数据，一条指令由操作码和若干参数组成 </li>\n<li>程序经过编译、链接后生成的指令指明的是逻辑地址(即相对地址，都是从0开始的)，需要通过内存管理策略将指令中的逻辑地址转换为正确的物理地址(绝对地址)</li>\n</ul>\n<h4 id=\"程序运行-逻辑地址-→-物理地址-的过程：\"><a href=\"#程序运行-逻辑地址-→-物理地址-的过程：\" class=\"headerlink\" title=\"程序运行(逻辑地址 → 物理地址)的过程：\"></a>程序运行(逻辑地址 → 物理地址)的过程：</h4><ul>\n<li>编译：将源代码文件(.c)生成目标模块(.o)(高级语言翻译为机器语言), 每一个目标模块都具有独立的逻辑地址 </li>\n<li>链接：目标模块生成装入模块(可执行文件,如.exe)，链接完成使得各模块形成整体的链接地址</li>\n<li>装入(载)：将装入模块装入内存运行，装入后形成物理地址</li>\n</ul>\n<img src=\"../images/OS/OS5.8.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"三种链接方式：\"><a href=\"#三种链接方式：\" class=\"headerlink\" title=\"三种链接方式：\"></a>三种链接方式：</h4><ul>\n<li>静态链接：装入前链接成一个完整模块</li>\n<li>装入时动态链接：运行前边装入边链接</li>\n<li>运行时动态链接：运行时需要什么模块才装入并链接，优点是便于修改和更新，便于实现对<br>目标模块的共享</li>\n</ul>\n<h4 id=\"三种装入方式：\"><a href=\"#三种装入方式：\" class=\"headerlink\" title=\"三种装入方式：\"></a>三种装入方式：</h4><ul>\n<li><p>绝对装入：</p>\n<p>编译后直接产生物理地址，只适用于单道程序环境(编译器负责实现，没有操作系统参与)</p>\n</li>\n<li><p>可重定位装入(静态重定位)：</p>\n<p>编译链接后的装入模块地址是逻辑地址，装入时进行重定位，据内存情况对指令地址和数据地址进行相应偏移，一旦运行后就不能改变，也不能再申请内存空间(早期多道批处理操作系统使用)</p>\n</li>\n<li><p>动态运行时装入(动态重定位)：</p>\n<p>装入后仍然是逻辑地址，地址转换推迟到运行时进行，需要设置重定位寄存器(或者叫基址寄存器) ，允许程序在内存中发生移动，而且程序可以分配到不连续的储存区，也支持动态申请内存(现代操作系统使用)</p>\n</li>\n</ul>\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><img src=\"../images/OS/OS5.9.png\" style=\"zoom:70%;\" />\n\n\n\n<h3 id=\"6-2-内存管理基础\"><a href=\"#6-2-内存管理基础\" class=\"headerlink\" title=\"6.2 内存管理基础\"></a>6.2 内存管理基础</h3><img src=\"../images/OS/OS5.10.png\" style=\"zoom:90%;\" />\n\n<p>上下限寄存器：存放进程的上、下限地址，进程的指令要访问某个地址时，CPU检查是否越界</p>\n<p>重定位寄存器(基址寄存器)：存放的是进程的起始物理地址</p>\n<p>界地址寄存器(限长寄存器)：存放的是进程的最大逻辑地址</p>\n<p>内存保护：通过设置上下限寄存器或重定位寄存器和界地址寄存器实现</p>\n<h3 id=\"6-3-内存空间的分配与回收-——-连续分配管理\"><a href=\"#6-3-内存空间的分配与回收-——-连续分配管理\" class=\"headerlink\" title=\"6.3 内存空间的分配与回收 —— 连续分配管理\"></a>6.3 内存空间的分配与回收 —— 连续分配管理</h3><h4 id=\"连续分配管理方式：\"><a href=\"#连续分配管理方式：\" class=\"headerlink\" title=\"连续分配管理方式：\"></a>连续分配管理方式：</h4><img src=\"../images/OS/OS6.1.png\" style=\"zoom:70%;\" />\n\n\n\n<h4 id=\"动态分区分配：\"><a href=\"#动态分区分配：\" class=\"headerlink\" title=\"动态分区分配：\"></a>动态分区分配：</h4><img src=\"../images/OS/OS6.2.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.3.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.4.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"6-4-动态分区算法\"><a href=\"#6-4-动态分区算法\" class=\"headerlink\" title=\"6.4 动态分区算法\"></a>6.4 动态分区算法</h3><ul>\n<li>首次适应(First Fit)<br>空闲分区按地址递增顺序排列，每次分配内存时查找空闲分区链(表)，找到第一个满足要求的分区即可          高地址的大分区更有可能被保存下来</li>\n<li>最佳适应(Best Fit)<br>空闲分区按容量递增顺序链接，每次分配内存时按顺序查找内存分区链(表)，找到第一个可以满足的空闲分区<br>优先使用最小得连续空闲区，尽可能多的留下大块空闲区，满足大进程需求，但是会留下非常多难以利用的外部碎片</li>\n<li>最坏适应(Worst Fit)<br>空闲分区按容量递减顺序排序，每次分配找到能满足要求的第一个空闲分区，又叫最大适应算法(Largest Fit)<br>优先使用最大的连续空闲区，使得分配后的剩余空闲区不会太小，但是如果以后有“大进程”到达会无内存区间可用</li>\n<li>邻近适应(Next Fit)<br>空闲分区按地址递增顺序构成循环链表，每次内存分配时从上次查找结束的位置开始，找到第一个能满足要求的空闲分区，又叫循环首次适应算法<br>无论是低地址还是高地址的空闲分区，都有相同的概率被使用，导致最后无大分区可用</li>\n</ul>\n<p>对比：</p>\n<img src=\"../images/OS/OS6.5.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"6-5-内存空间的分配与回收-——-非连续分配管理\"><a href=\"#6-5-内存空间的分配与回收-——-非连续分配管理\" class=\"headerlink\" title=\"6.5 内存空间的分配与回收 —— 非连续分配管理\"></a>6.5 内存空间的分配与回收 —— 非连续分配管理</h3><h4 id=\"6-5-1-分页存储管理\"><a href=\"#6-5-1-分页存储管理\" class=\"headerlink\" title=\"6.5.1 分页存储管理\"></a>6.5.1 分页存储管理</h4><p>分页管理基础知识：</p>\n<img src=\"../images/OS/OS6.6.png\" style=\"zoom:90%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.7.png\" style=\"zoom:90%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.8.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.9.png\" style=\"zoom:90%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.10.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.11.png\" style=\"zoom:90%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.12.png\" style=\"zoom:80%;\" />\n\n<hr>\n<p>基本地址变换：</p>\n<img src=\"../images/OS/OS6.13.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS6.14.png\" style=\"zoom:80%;\" />\n\n\n\n<p>引入快表的地址变换:</p>\n<ul>\n<li><p>快表又称联想寄存器(TLB， translation lookaside buffer) ,是一种访问速度比内存快很多的高速缓存(TLB不是内存),用来存放最近访问的页表项的副本，可以加速地址变换的速度(局部性原理)。所以内存中的页表常称为慢表</p>\n</li>\n<li><p>局部性原理：</p>\n<ul>\n<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问</li>\n<li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问(因为很多数据在内存中都是连续存放的）</li>\n</ul>\n</li>\n<li><p>引入快表后的地址变换过程：</p>\n<img src=\"../images/OS/OS6.15.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<p>两级页表：</p>\n<ul>\n<li><p>原理：</p>\n<img src=\"../images/OS/OS6.16.png\" style=\"zoom:80%;\" /></li>\n<li><p>地址变换过程：</p>\n<img src=\"../images/OS/OS6.17.png\" style=\"zoom:80%;\" /></li>\n<li><p>注意：</p>\n<img src=\"../images/OS/OS6.18.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<h4 id=\"6-5-2-分段存储管理\"><a href=\"#6-5-2-分段存储管理\" class=\"headerlink\" title=\"6.5.2 分段存储管理\"></a>6.5.2 分段存储管理</h4><ul>\n<li><p>原理：</p>\n<img src=\"../images/OS/OS6.21.png\" style=\"zoom:80%;\" /></li>\n<li><p>段表：</p>\n<img src=\"../images/OS/OS6.19.png\" style=\"zoom:80%;\" /></li>\n<li><p>地址变换过程：</p>\n<img src=\"../images/OS/OS6.20.png\" style=\"zoom:80%;\" /></li>\n<li><p>分段与分页对比：</p>\n<img src=\"../images/OS/OS6.22.png\" style=\"zoom:80%;\" /></li>\n<li><p>注意：</p>\n<img src=\"../images/OS/OS6.23.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<h4 id=\"6-5-3-段页式存储管理\"><a href=\"#6-5-3-段页式存储管理\" class=\"headerlink\" title=\"6.5.3 段页式存储管理\"></a>6.5.3 段页式存储管理</h4><ul>\n<li><p>分页、分段优缺点：</p>\n<img src=\"../images/OS/OS6.24.png\" style=\"zoom:80%;\" /></li>\n<li><p>段页式原理：</p>\n<img src=\"../images/OS/OS6.25.png\" style=\"zoom:80%;\" /></li>\n<li><p>段表、页表：</p>\n<img src=\"../images/OS/OS6.26.png\" style=\"zoom:80%;\" /></li>\n<li><p>地址变换过程：</p>\n</li>\n</ul>\n<img src=\"../images/OS/OS6.27.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"6-6-内存空间的扩充-——-覆盖与交换技术\"><a href=\"#6-6-内存空间的扩充-——-覆盖与交换技术\" class=\"headerlink\" title=\"6.6 内存空间的扩充 —— 覆盖与交换技术\"></a>6.6 内存空间的扩充 —— 覆盖与交换技术</h3><h4 id=\"覆盖技术：\"><a href=\"#覆盖技术：\" class=\"headerlink\" title=\"覆盖技术：\"></a>覆盖技术：</h4><ul>\n<li>覆盖技术的引入是为了解决“程序大小超过物理内存总和”的问题</li>\n<li>覆盖技术思想：将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)；不常用的段放在“覆盖区”，需要时才调入内存</li>\n<li>缺点：必须由程序员声明覆盖结构，对用户不透明，增加编程负担，只用于早期操作系统中</li>\n</ul>\n<h4 id=\"交换技术：\"><a href=\"#交换技术：\" class=\"headerlink\" title=\"交换技术：\"></a>交换技术：</h4><ul>\n<li>交换技术思想：内存紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</li>\n<li> 交换技术的体现：进程的中级调度(内存调度)，七状态模型中的就绪挂起和阻塞挂起</li>\n<li>磁盘分为对换区(swap)和文件区，前者连续分配追求I/O速度，后者离散分配追求存储空间利用率 </li>\n<li>优先换出阻塞进程、低优先级进程</li>\n<li>为了防止优先级低的进程在被调入内存后很快又被换出，系统还会考虑进程在内存的驻留时间</li>\n<li>PCB 会常驻内存，不会被换出外存</li>\n</ul>\n<p>补充：覆盖与交换的区别</p>\n<p>覆盖是在同一个程序或进程中，交换是在不同进程或作业之间</p>\n<h3 id=\"6-7-内存空间的扩充-——-虚拟内存技术\"><a href=\"#6-7-内存空间的扩充-——-虚拟内存技术\" class=\"headerlink\" title=\"6.7 内存空间的扩充 —— 虚拟内存技术\"></a>6.7 内存空间的扩充 —— 虚拟内存技术</h3><h4 id=\"传统存储管理方式-连续分配和非连续分配-的局限：\"><a href=\"#传统存储管理方式-连续分配和非连续分配-的局限：\" class=\"headerlink\" title=\"传统存储管理方式(连续分配和非连续分配)的局限：\"></a>传统存储管理方式(连续分配和非连续分配)的局限：</h4><ul>\n<li>一次性：作业必须一次性全部装入内存后才能开始运行，导致大作业无法运行,多道程序并发度下降</li>\n<li>驻留性：作业在运行期间一直驻留在内存，内存中驻留大量的暂时用不到的数据，浪费内存资源</li>\n</ul>\n<h4 id=\"局部性原理：\"><a href=\"#局部性原理：\" class=\"headerlink\" title=\"局部性原理：\"></a>局部性原理：</h4><ul>\n<li>时间局部性：现在访问的指令、数据在不久后很可能再次访问</li>\n<li>空间局部性：现在访问的内存单元周围的内存空间很可能在不久之后访问</li>\n<li>高速缓存：近期频繁访问的数据放到更高速的储存器中</li>\n</ul>\n<h4 id=\"虚拟内存的定义：\"><a href=\"#虚拟内存的定义：\" class=\"headerlink\" title=\"虚拟内存的定义：\"></a>虚拟内存的定义：</h4><p>程序不需要全部装入内存即可运行，运行时根据需要动态调入数据，若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p>\n<h4 id=\"虚拟内存的特征：\"><a href=\"#虚拟内存的特征：\" class=\"headerlink\" title=\"虚拟内存的特征：\"></a>虚拟内存的特征：</h4><ul>\n<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li>\n<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换<br>入、换出</li>\n<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量</li>\n</ul>\n<h4 id=\"虚拟内存技术的实现-请求调页-页面置换-：\"><a href=\"#虚拟内存技术的实现-请求调页-页面置换-：\" class=\"headerlink\" title=\"虚拟内存技术的实现(请求调页 + 页面置换)：\"></a>虚拟内存技术的实现(请求调页 + 页面置换)：</h4><ul>\n<li><p>请求调页：访问的信息不存在时，操作系统负责将需要的信息从外存调入内存</p>\n</li>\n<li><p>页面置换：内存空间不足时，将内存中暂时不用的信息换到外存</p>\n</li>\n<li><p>请求调页包括请求分页、请求分段和请求段页式；页面置换通过相关算法实现</p>\n</li>\n</ul>\n<h3 id=\"6-8-虚拟内存技术的实现-——-请求分页管理方式\"><a href=\"#6-8-虚拟内存技术的实现-——-请求分页管理方式\" class=\"headerlink\" title=\"6.8 虚拟内存技术的实现 —— 请求分页管理方式\"></a>6.8 虚拟内存技术的实现 —— 请求分页管理方式</h3><ul>\n<li><p>请求分页管理的页表机制：</p>\n<img src=\"../images/OS/OS6.28.png\" style=\"zoom:70%;\" /></li>\n<li><p>请求分页管理的缺页中断机构：</p>\n<img src=\"../images/OS/OS6.29.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<p>注意：缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断中的故障(fault)，一条指令在执行期间可能产生多次缺页中断</p>\n<ul>\n<li><p>请求分页管理的地址变换：</p>\n<img src=\"../images/OS/OS6.30.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<h3 id=\"6-9-页面置换算法\"><a href=\"#6-9-页面置换算法\" class=\"headerlink\" title=\"6.9 页面置换算法\"></a>6.9 页面置换算法</h3><ul>\n<li><p>最佳置换算法(OPT)：</p>\n<img src=\"../images/OS/OS6.31.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>先进先出置换算法(OPT)：</p>\n<img src=\"../images/OS/OS6.32.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>最近最久未使用算法(LRU)</p>\n<img src=\"../images/OS/OS6.33.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>时钟置换算法(CLOCK)：</p>\n<img src=\"../images/OS/OS6.34.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>改进后的时钟置换算法：</p>\n<img src=\"../images/OS/OS6.35.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>对比：</p>\n<img src=\"../images/OS/OS6.36.png\" style=\"zoom:60%;\" /></li>\n</ul>\n<h3 id=\"6-10-页面分配和置换策略\"><a href=\"#6-10-页面分配和置换策略\" class=\"headerlink\" title=\"6.10 页面分配和置换策略\"></a>6.10 页面分配和置换策略</h3><h4 id=\"基本概念：\"><a href=\"#基本概念：\" class=\"headerlink\" title=\"基本概念：\"></a>基本概念：</h4><img src=\"../images/OS/OS6.37.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"固定分配局部置换：\"><a href=\"#固定分配局部置换：\" class=\"headerlink\" title=\"固定分配局部置换：\"></a>固定分配局部置换：</h4><ul>\n<li>系统为每个进程分配一定数量的物理块,在整个运行期间都不改变。</li>\n<li>若进程在运行中发生缺页,则只能从该进程在内存中的页面中选出一页换出,然后再调入需要的页面</li>\n<li> 缺点:很难在刚开始就确定应为每个进程分配多少个物理块才算合理</li>\n<li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li>\n</ul>\n<h4 id=\"可变分配全局置换：\"><a href=\"#可变分配全局置换：\" class=\"headerlink\" title=\"可变分配全局置换：\"></a>可变分配全局置换：</h4><ul>\n<li>刚开始会为每个进程分配一定数量的物理块，操作系统会保持一个空闲物理块队列</li>\n<li>当某进程发生缺页时,从空闲物理块中取出一块分配给该进程；若已无空闲物理块,则可选择一个未锁定的页面换出外存,再将该物理块分配给缺页的进程</li>\n<li>只要某进程缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出</li>\n<li>被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少,缺页率会增加</li>\n</ul>\n<h4 id=\"可变分配局部置换-常用策略-：\"><a href=\"#可变分配局部置换-常用策略-：\" class=\"headerlink\" title=\"可变分配局部置换(常用策略)：\"></a>可变分配局部置换(常用策略)：</h4><ul>\n<li>刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存</li>\n<li>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度</li>\n<li>反之,如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块</li>\n</ul>\n<h4 id=\"调入页面的时机：\"><a href=\"#调入页面的时机：\" class=\"headerlink\" title=\"调入页面的时机：\"></a>调入页面的时机：</h4><ul>\n<li>预调页策略：<ul>\n<li>根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效</li>\n<li>但如果提前调入的页面中大多数都没被访问过，则又是低效的</li>\n<li>因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分</li>\n</ul>\n</li>\n<li> 请求调页策略：</li>\n<li>进程在运行期间发现缺页时才将所缺页面调入内存，由这种策略调入的页面一定会被访问到</li>\n<li>由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大</li>\n</ul>\n<h4 id=\"调入页面的位置：\"><a href=\"#调入页面的位置：\" class=\"headerlink\" title=\"调入页面的位置：\"></a>调入页面的位置：</h4><ol>\n<li><p>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区</p>\n</li>\n<li><p>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</p>\n</li>\n<li><p>UNIX 方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</p>\n</li>\n</ol>\n<img src=\"../images/OS/OS6.38.png\" style=\"zoom:70%;\" />\n\n<h4 id=\"抖动-颠簸-现象：\"><a href=\"#抖动-颠簸-现象：\" class=\"headerlink\" title=\"抖动(颠簸)现象：\"></a>抖动(颠簸)现象：</h4><ul>\n<li>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称<br>为抖动(颠簸)</li>\n<li>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）</li>\n<li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程“工作集”的概念</li>\n</ul>\n<h4 id=\"工作集：\"><a href=\"#工作集：\" class=\"headerlink\" title=\"工作集：\"></a>工作集：</h4><img src=\"../images/OS/OS6.39.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"6-11-内存映射文件-Memory-Mapped-Files\"><a href=\"#6-11-内存映射文件-Memory-Mapped-Files\" class=\"headerlink\" title=\"6.11 内存映射文件(Memory-Mapped Files)\"></a>6.11 内存映射文件(Memory-Mapped Files)</h3><p>定义：操作系统向其上层程序员提供的一种系统调用功能，方便对文件数据的访问和多个进程共享同一个文件</p>\n<p>特点：</p>\n<ul>\n<li>进程可以使用系统调用，请求操作系统将文件映射道进程的虚拟地址空间，以访问内存的形式读写文件</li>\n<li>进程文件关闭时，操作系统负责将文件数据写回磁盘，并解除内存映射</li>\n<li>多个进程可以映射同一个文件，方便共享</li>\n</ul>\n<hr>\n<h1 id=\"第七章-文件管理\"><a href=\"#第七章-文件管理\" class=\"headerlink\" title=\"第七章 文件管理\"></a>第七章 文件管理</h1><h3 id=\"7-1-文件管理基础\"><a href=\"#7-1-文件管理基础\" class=\"headerlink\" title=\"7.1  文件管理基础\"></a>7.1  文件管理基础</h3><img src=\"../images/OS/OS7.1.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-2-文件的逻辑结构\"><a href=\"#7-2-文件的逻辑结构\" class=\"headerlink\" title=\"7.2 文件的逻辑结构\"></a>7.2 文件的逻辑结构</h3><img src=\"../images/OS/OS7.2.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS7.3.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-3-文件目录-Flie-Directory\"><a href=\"#7-3-文件目录-Flie-Directory\" class=\"headerlink\" title=\"7.3 文件目录(Flie Directory)\"></a>7.3 文件目录(Flie Directory)</h3><img src=\"../images/OS/OS7.4.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-4-文件的物理结构-文件分配方式\"><a href=\"#7-4-文件的物理结构-文件分配方式\" class=\"headerlink\" title=\"7.4 文件的物理结构(文件分配方式)\"></a>7.4 文件的物理结构(文件分配方式)</h3><h4 id=\"分配方式：\"><a href=\"#分配方式：\" class=\"headerlink\" title=\"分配方式：\"></a>分配方式：</h4><img src=\"../images/OS/OS7.5.png\" style=\"zoom:67%;\" />\n\n\n\n<h4 id=\"文件快和磁盘块：\"><a href=\"#文件快和磁盘块：\" class=\"headerlink\" title=\"文件快和磁盘块：\"></a>文件快和磁盘块：</h4><img src=\"../images/OS/OS7.6.png\" style=\"zoom:80%;\" />\n\n<p>内存与磁盘之间的数据交换(即读/写操作、磁盘I/O)都是以“块”为单位进行的。即每次读入一块，或每次写出一块</p>\n<h4 id=\"连续分配：\"><a href=\"#连续分配：\" class=\"headerlink\" title=\"连续分配：\"></a>连续分配：</h4><img src=\"../images/OS/OS7.7.png\" style=\"zoom:80%;\" />\n\n<p>优点：支持顺序访问和随机访问(直接访问)；顺序访问时速度最快(移动磁头所需的时间短) </p>\n<p>缺点：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片</p>\n<h4 id=\"链接分配-——-隐式链接：\"><a href=\"#链接分配-——-隐式链接：\" class=\"headerlink\" title=\"链接分配 —— 隐式链接：\"></a>链接分配 —— 隐式链接：</h4><img src=\"../images/OS/OS7.8.png\" style=\"zoom:80%;\" />\n\n<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。<br>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量<br>的存储空间</p>\n<h4 id=\"链接分配-——-显式链接：\"><a href=\"#链接分配-——-显式链接：\" class=\"headerlink\" title=\"链接分配 —— 显式链接：\"></a>链接分配 —— 显式链接：</h4><img src=\"../images/OS/OS7.9.png\" style=\"zoom:80%;\" />\n\n<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换换时不需要访问磁盘，因此文件的访问效率更高<br>缺点：文件分配表的需要占用一定的存储空间</p>\n<h4 id=\"索引分配：\"><a href=\"#索引分配：\" class=\"headerlink\" title=\"索引分配：\"></a>索引分配：</h4><img src=\"../images/OS/OS7.10.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS7.11.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"对索引分配的改进：\"><a href=\"#对索引分配的改进：\" class=\"headerlink\" title=\"对索引分配的改进：\"></a>对索引分配的改进：</h4><img src=\"../images/OS/OS7.12.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"分配方式对比：\"><a href=\"#分配方式对比：\" class=\"headerlink\" title=\"分配方式对比：\"></a>分配方式对比：</h4><img src=\"../images/OS/OS7.13.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-5-文件存储空间管理方法\"><a href=\"#7-5-文件存储空间管理方法\" class=\"headerlink\" title=\"7.5 文件存储空间管理方法\"></a>7.5 文件存储空间管理方法</h3><h4 id=\"存储空间划分与初始化：\"><a href=\"#存储空间划分与初始化：\" class=\"headerlink\" title=\"存储空间划分与初始化：\"></a>存储空间划分与初始化：</h4><img src=\"../images/OS/OS7.27.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"空闲表法：\"><a href=\"#空闲表法：\" class=\"headerlink\" title=\"空闲表法：\"></a>空闲表法：</h4><img src=\"../images/OS/OS7.29.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"空闲链表法：\"><a href=\"#空闲链表法：\" class=\"headerlink\" title=\"空闲链表法：\"></a>空闲链表法：</h4><ul>\n<li><p>空闲盘块链</p>\n<img src=\"../images/OS/OS7.30.png\" style=\"zoom:80%;\" /></li>\n<li><p>空闲盘区链</p>\n<img src=\"../images/OS/OS7.31.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<h4 id=\"位示图法：\"><a href=\"#位示图法：\" class=\"headerlink\" title=\"位示图法：\"></a>位示图法：</h4><img src=\"../images/OS/OS7.32.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"成组链接法：\"><a href=\"#成组链接法：\" class=\"headerlink\" title=\"成组链接法：\"></a>成组链接法：</h4><p>适用于大型文件系统，文件卷的目录区中，专门用一个磁盘块作为超级块，系统启动时读入内存，并且保持内外存超级块数据同步</p>\n<img src=\"../images/OS/OS7.33.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-6-文件的基本操作\"><a href=\"#7-6-文件的基本操作\" class=\"headerlink\" title=\"7.6 文件的基本操作\"></a>7.6 文件的基本操作</h3><img src=\"../images/OS/OS7.14.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-7-文件共享\"><a href=\"#7-7-文件共享\" class=\"headerlink\" title=\"7.7 文件共享\"></a>7.7 文件共享</h3><img src=\"../images/OS/OS7.15.png\" style=\"zoom:80%;\" />\n\n<h3 id=\"7-8-文件保护\"><a href=\"#7-8-文件保护\" class=\"headerlink\" title=\"7.8 文件保护\"></a>7.8 文件保护</h3><img src=\"../images/OS/OS7.16.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"7-9-文件系统的层次结构\"><a href=\"#7-9-文件系统的层次结构\" class=\"headerlink\" title=\"7.9 文件系统的层次结构\"></a>7.9 文件系统的层次结构</h3><img src=\"../images/OS/OS7.17.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS7.20.png\" style=\"zoom:80%;\" />\n\n<h3 id=\"7-10-虚拟文件系统VFS\"><a href=\"#7-10-虚拟文件系统VFS\" class=\"headerlink\" title=\"7.10 虚拟文件系统VFS\"></a>7.10 虚拟文件系统VFS</h3><p>VFS特点：</p>\n<ul>\n<li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li>\n<li>VFS要求下层的文件系统必须实现某些特定的函数功能(如open、read、write等)</li>\n<li>每打开一个文件，VFS就在主存中新建一个vnode(只存在于主存中),用统一的数据结构标识该文件，无论该文件存储在哪个文件系统一</li>\n</ul>\n<p>文件系统挂载(mounting)：</p>\n<p>又见文件系统安装/装载，解决如何将一个文件系统挂载到操作系统中</p>\n<ol>\n<li>在VFS中注册要挂在的文件系统，添加到内存中的挂载表(mount table)中，包含文件系统的相关信息</li>\n<li>向VFS提供一个函数地址列表，使VFS能够调用相关功能</li>\n<li>将文件系统加到挂载点(mount point，也就是挂载到某个父目录下)</li>\n</ol>\n<h3 id=\"7-11-磁盘的结构\"><a href=\"#7-11-磁盘的结构\" class=\"headerlink\" title=\"7.11 磁盘的结构\"></a>7.11 磁盘的结构</h3><ul>\n<li><p>磁盘、磁道、扇区：</p>\n<img src=\"../images/OS/OS7.21.png\" style=\"zoom:67%;\" /></li>\n</ul>\n<ul>\n<li><p>磁盘读写数据过程：</p>\n<p>“磁头”先移动到想要读/写扇区所在的磁道，磁盘转动后，让目标扇区从磁头下划过，完成对扇区的读写操作</p>\n</li>\n</ul>\n<ul>\n<li><p>盘面、柱面、磁盘的物理地址：</p>\n<img src=\"../images/OS/OS7.22.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>磁盘的分类：</p>\n<img src=\"../images/OS/OS7.23.png\" style=\"zoom:67%;\" /></li>\n</ul>\n<h3 id=\"7-12-磁盘调度算法\"><a href=\"#7-12-磁盘调度算法\" class=\"headerlink\" title=\"7.12 磁盘调度算法\"></a>7.12 磁盘调度算法</h3><h4 id=\"读写时间：\"><a href=\"#读写时间：\" class=\"headerlink\" title=\"读写时间：\"></a>读写时间：</h4><img src=\"../images/OS/OS7.24.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"调度算法：\"><a href=\"#调度算法：\" class=\"headerlink\" title=\"调度算法：\"></a>调度算法：</h4><ul>\n<li>先来先服务(FCFS)<br>根据进程请求访问磁盘的先后顺序调度<br>公平；如果大量进程访问的磁道很分散，虚拟会很差</li>\n<li>最短寻道时间优先(SSTF)<br>优先处理当前磁头最近的磁道，保证寻道时间最短(贪心算法思想，眼前最优，未必整体最优)<br>性能较好，但是可能产生饥饿现象</li>\n<li>扫描算法(SCAN)<br>又叫电梯算法，在SSTF算法的基础上，规定磁头只有移动到磁道尽头(最外侧或者最内侧)才能往回移动<br>性能较好，不会饥饿；但是只能扫描到最边上的磁道才能改变磁头方向，越外侧的的磁道，响应频率越高</li>\n<li>LOOK调度算法<br>改进SCAN算法，磁头边移动边观察(LOOK)，如果移动方向没有请求了，就不必继续扫描，直接调头</li>\n<li>循环扫描算法(C-SCAN)<br>只有磁头朝着某个方向移动(比如磁道号增大方向)时才处理访问请求，移动到最边上后直接返回到另一边(0号磁道)，返回途中不处理请求<br>相比SACN算法，各个位置的磁道响应频率很平均</li>\n<li>C-LOOK算法<br>改进C-SCAN算法，磁头移动方向上如果没有请求了，就直接返回到最靠近边缘的请求磁道即可</li>\n</ul>\n<h3 id=\"7-13-减少磁盘时延\"><a href=\"#7-13-减少磁盘时延\" class=\"headerlink\" title=\"7.13 减少磁盘时延\"></a>7.13 减少磁盘时延</h3><p>造成原因：磁盘读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</p>\n<h4 id=\"减少磁盘时延的方法：\"><a href=\"#减少磁盘时延的方法：\" class=\"headerlink\" title=\"减少磁盘时延的方法：\"></a>减少磁盘时延的方法：</h4><ul>\n<li><p>交替编号：</p>\n<p>采用交替编号的策略，让逻辑相邻的扇区在物理上有一定间隔，使读取连续逻辑扇区所需的延迟时间更小</p>\n</li>\n<li><p>磁盘物理地址设计：</p>\n<img src=\"../images/OS/OS7.25.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<ul>\n<li><p>错位命名：</p>\n<img src=\"../images/OS/OS7.26.png\" style=\"zoom:80%;\" /></li>\n</ul>\n<hr>\n<h1 id=\"第八章-I-O-input-output-设备管理\"><a href=\"#第八章-I-O-input-output-设备管理\" class=\"headerlink\" title=\"第八章 I/O(input/output)设备管理\"></a>第八章 I/O(input/output)设备管理</h1><h3 id=\"8-1-I-O设备的分类\"><a href=\"#8-1-I-O设备的分类\" class=\"headerlink\" title=\"8.1 I/O设备的分类\"></a>8.1 I/O设备的分类</h3><img src=\"../images/OS/OS8.1.png\" style=\"zoom:75%;\" />\n\n\n\n<h3 id=\"8-2-I-O控制器\"><a href=\"#8-2-I-O控制器\" class=\"headerlink\" title=\"8.2 I/O控制器\"></a>8.2 I/O控制器</h3><p>概述：</p>\n<img src=\"../images/OS/OS8.2.png\" style=\"zoom:80%;\" />\n\n\n\n<p>I/O控制器的组成：</p>\n<img src=\"../images/OS/OS8.3.png\" style=\"zoom:90%;\" />\n\n\n\n<p>寄存器编址方式：</p>\n<img src=\"../images/OS/OS8.4.png\" style=\"zoom:90%;\" />\n\n\n\n<h3 id=\"8-3-I-O控制方式\"><a href=\"#8-3-I-O控制方式\" class=\"headerlink\" title=\"8.3 I/O控制方式\"></a>8.3 I/O控制方式</h3><h4 id=\"程序直接控制方式：\"><a href=\"#程序直接控制方式：\" class=\"headerlink\" title=\"程序直接控制方式：\"></a>程序直接控制方式：</h4><img src=\"../images/OS/OS8.5.png\" style=\"zoom:90%;\" />\n\n\n\n<h4 id=\"中断驱动方式：\"><a href=\"#中断驱动方式：\" class=\"headerlink\" title=\"中断驱动方式：\"></a>中断驱动方式：</h4><img src=\"../images/OS/OS8.6.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"直接存储器存取-DMA-Direct-Memory-Access-方式：\"><a href=\"#直接存储器存取-DMA-Direct-Memory-Access-方式：\" class=\"headerlink\" title=\"直接存储器存取(DMA, Direct Memory Access)方式：\"></a>直接存储器存取(DMA, Direct Memory Access)方式：</h4><img src=\"../images/OS/OS8.7.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.8.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"通道控制方式：\"><a href=\"#通道控制方式：\" class=\"headerlink\" title=\"通道控制方式：\"></a>通道控制方式：</h4><img src=\"../images/OS/OS8.9.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.10.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"对比：\"><a href=\"#对比：\" class=\"headerlink\" title=\"对比：\"></a>对比：</h4><img src=\"../images/OS/OS8.11.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"8-4-I-O软件层次结构\"><a href=\"#8-4-I-O软件层次结构\" class=\"headerlink\" title=\"8.4 I/O软件层次结构\"></a>8.4 I/O软件层次结构</h3><h4 id=\"层次总览：\"><a href=\"#层次总览：\" class=\"headerlink\" title=\"层次总览：\"></a>层次总览：</h4><img src=\"../images/OS/OS8.12.png\" style=\"zoom:60%;\" />\n\n\n\n<h4 id=\"各层次功能：\"><a href=\"#各层次功能：\" class=\"headerlink\" title=\"各层次功能：\"></a>各层次功能：</h4><img src=\"../images/OS/OS8.13.png\" style=\"zoom:100%;\" />\n\n\n\n<h3 id=\"8-5-假脱机技术-SPOOLing\"><a href=\"#8-5-假脱机技术-SPOOLing\" class=\"headerlink\" title=\"8.5 假脱机技术(SPOOLing)\"></a>8.5 假脱机技术(SPOOLing)</h3><p>定义：</p>\n<p>脱机技术指脱离主机的控制进行输入输出操作，假脱机技术指用软件的方式模拟脱机技术</p>\n<p>SPOOLing系统的组成：</p>\n<img src=\"../images/OS/OS8.14.png\" style=\"zoom:60%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.15.png\" style=\"zoom:80%;\" />\n\n\n\n<p>应用 —— 共享打印机：</p>\n<img src=\"../images/OS/OS8.16.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"8-6-设备的分配与回收\"><a href=\"#8-6-设备的分配与回收\" class=\"headerlink\" title=\"8.6 设备的分配与回收\"></a>8.6 设备的分配与回收</h3><h4 id=\"设备分配时应考虑的因素：\"><a href=\"#设备分配时应考虑的因素：\" class=\"headerlink\" title=\"设备分配时应考虑的因素：\"></a>设备分配时应考虑的因素：</h4><ul>\n<li><p>固有属性：</p>\n<img src=\"../images/OS/OS8.17.png\" style=\"zoom:70%;\" /></li>\n<li><p>设备分配算法：</p>\n<p>先来先服务、优先级高者优先、短任务优先等等</p>\n</li>\n<li><p>设备分配中的安全性：</p>\n<img src=\"../images/OS/OS8.18.png\" style=\"zoom:70%;\" /></li>\n</ul>\n<h4 id=\"设备分配管理中的数据结构：\"><a href=\"#设备分配管理中的数据结构：\" class=\"headerlink\" title=\"设备分配管理中的数据结构：\"></a>设备分配管理中的数据结构：</h4><img src=\"../images/OS/OS8.19.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.20.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.21.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.22.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.23.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"设备分配过程：\"><a href=\"#设备分配过程：\" class=\"headerlink\" title=\"设备分配过程：\"></a>设备分配过程：</h4><img src=\"../images/OS/OS8.24.png\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"设备分配过程改进：\"><a href=\"#设备分配过程改进：\" class=\"headerlink\" title=\"设备分配过程改进：\"></a>设备分配过程改进：</h4><img src=\"../images/OS/OS8.25.png\" style=\"zoom:80%;\" />\n\n<hr>\n<img src=\"../images/OS/OS8.26.png\" style=\"zoom:80%;\" />\n\n\n\n<h3 id=\"8-7-缓冲区管理\"><a href=\"#8-7-缓冲区管理\" class=\"headerlink\" title=\"8.7 缓冲区管理\"></a>8.7 缓冲区管理</h3><p>缓冲区：</p>\n<p>一个存储区域，可以由专门的硬件寄存器组成(成本较高、容量也较小)，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p>\n<p>缓冲区的作用：</p>\n<ul>\n<li>缓和CPU与I/O之间速度不匹配的矛盾 </li>\n<li>减少对CPU的中断频率，放宽对CPU中断的时间限制(中断驱动的字符型设备) </li>\n<li>解决数据粒度不匹配的问题(字符型/块型)</li>\n<li>提高CPU与I/O的并行性</li>\n</ul>\n<p>单缓冲：</p>\n<img src=\"../images/OS/OS8.27.png\" style=\"zoom:99%;\" />\n\n\n\n<p>双缓冲：</p>\n<img src=\"../images/OS/OS8.28.png\" style=\"zoom:99%;\" />\n\n<img src=\"../images/OS/OS8.29.png\" style=\"zoom:80%;\" />\n\n\n\n<p>循环缓冲区：</p>\n<img src=\"../images/OS/OS8.30.png\" style=\"zoom:70%;\" />\n\n\n\n<p>缓冲池：</p>\n<img src=\"../images/OS/OS8.31.png\" style=\"zoom:80%;\" />\n","feature":true,"text":"第五章 死锁5.1 死锁基本概念死锁：并发环境下，各进程因为竞争资源造成的互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象 除对系统资源的竞争外，进程推进非法和信号量使用不当等情况也会造成死锁 死锁、饥饿和死循环 死锁产生的条件： 互斥条件：争抢必须互斥使用的资源 不...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"操作系统","slug":"操作系统","count":2,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">第五章 死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E6%AD%BB%E9%94%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.1 死锁基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">死锁：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E5%92%8C%E6%AD%BB%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">死锁、饥饿和死循环</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">死锁产生的条件：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5%EF%BC%9A\"><span class=\"toc-text\">死锁的处理策略：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86-%E2%80%94%E2%80%94-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">5.2 死锁的处理 —— 预防死锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86-%E2%80%94%E2%80%94-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">5.3 死锁的处理 —— 避免死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97%E4%B8%8E%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%EF%BC%9A\"><span class=\"toc-text\">安全序列与安全状态：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">银行家算法：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86-%E2%80%94%E2%80%94-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4\"><span class=\"toc-text\">5.4 死锁的处理 —— 死锁的检测和解除</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%EF%BC%9A\"><span class=\"toc-text\">死锁检测：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4%EF%BC%9A\"><span class=\"toc-text\">死锁解除：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第六章 内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">6.1 内存基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">内存相关概念：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">指令的工作原理：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E2%86%92-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">程序运行(逻辑地址 → 物理地址)的过程：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">三种链接方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">三种装入方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A-1\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">6.2 内存管理基础</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6-%E2%80%94%E2%80%94-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.3 内存空间的分配与回收 —— 连续分配管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">连续分配管理方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%EF%BC%9A\"><span class=\"toc-text\">动态分区分配：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-4-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">6.4 动态分区算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-5-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6-%E2%80%94%E2%80%94-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.5 内存空间的分配与回收 —— 非连续分配管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-5-1-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.5.1 分页存储管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-5-2-%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.5.2 分段存储管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-5-3-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.5.3 段页式存储管理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-6-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85-%E2%80%94%E2%80%94-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">6.6 内存空间的扩充 —— 覆盖与交换技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%EF%BC%9A\"><span class=\"toc-text\">覆盖技术：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%EF%BC%9A\"><span class=\"toc-text\">交换技术：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-7-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85-%E2%80%94%E2%80%94-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">6.7 内存空间的扩充 —— 虚拟内存技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%92%8C%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D-%E7%9A%84%E5%B1%80%E9%99%90%EF%BC%9A\"><span class=\"toc-text\">传统存储管理方式(连续分配和非连续分配)的局限：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">局部性原理：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A\"><span class=\"toc-text\">虚拟内存的定义：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A\"><span class=\"toc-text\">虚拟内存的特征：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2-%EF%BC%9A\"><span class=\"toc-text\">虚拟内存技术的实现(请求调页 + 页面置换)：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-8-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0-%E2%80%94%E2%80%94-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">6.8 虚拟内存技术的实现 —— 请求分页管理方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-9-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">6.9 页面置换算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-10-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E5%92%8C%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">6.10 页面分配和置换策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">基本概念：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2%EF%BC%9A\"><span class=\"toc-text\">固定分配局部置换：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2%EF%BC%9A\"><span class=\"toc-text\">可变分配全局置换：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2-%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5-%EF%BC%9A\"><span class=\"toc-text\">可变分配局部置换(常用策略)：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA%EF%BC%9A\"><span class=\"toc-text\">调入页面的时机：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9A\"><span class=\"toc-text\">调入页面的位置：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%96%E5%8A%A8-%E9%A2%A0%E7%B0%B8-%E7%8E%B0%E8%B1%A1%EF%BC%9A\"><span class=\"toc-text\">抖动(颠簸)现象：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E9%9B%86%EF%BC%9A\"><span class=\"toc-text\">工作集：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-11-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6-Memory-Mapped-Files\"><span class=\"toc-text\">6.11 内存映射文件(Memory-Mapped Files)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第七章 文件管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">7.1  文件管理基础</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">7.2 文件的逻辑结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95-Flie-Directory\"><span class=\"toc-text\">7.3 文件目录(Flie Directory)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">7.4 文件的物理结构(文件分配方式)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">分配方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%BF%AB%E5%92%8C%E7%A3%81%E7%9B%98%E5%9D%97%EF%BC%9A\"><span class=\"toc-text\">文件快和磁盘块：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%EF%BC%9A\"><span class=\"toc-text\">连续分配：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D-%E2%80%94%E2%80%94-%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">链接分配 —— 隐式链接：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D-%E2%80%94%E2%80%94-%E6%98%BE%E5%BC%8F%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">链接分配 —— 显式链接：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%EF%BC%9A\"><span class=\"toc-text\">索引分配：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9A\"><span class=\"toc-text\">对索引分配的改进：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%EF%BC%9A\"><span class=\"toc-text\">分配方式对比：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-5-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">7.5 文件存储空间管理方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A\"><span class=\"toc-text\">存储空间划分与初始化：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">空闲表法：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">空闲链表法：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">位示图法：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">成组链接法：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-6-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">7.6 文件的基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">7.7 文件共享</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-8-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">7.8 文件保护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">7.9 文件系统的层次结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-10-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FVFS\"><span class=\"toc-text\">7.10 虚拟文件系统VFS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-11-%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">7.11 磁盘的结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-12-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">7.12 磁盘调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%86%99%E6%97%B6%E9%97%B4%EF%BC%9A\"><span class=\"toc-text\">读写时间：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">调度算法：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-13-%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E6%97%B6%E5%BB%B6\"><span class=\"toc-text\">7.13 减少磁盘时延</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E6%97%B6%E5%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">减少磁盘时延的方法：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%85%AB%E7%AB%A0-I-O-input-output-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">第八章 I&#x2F;O(input&#x2F;output)设备管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">8.1 I&#x2F;O设备的分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2-I-O%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">8.2 I&#x2F;O控制器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">8.3 I&#x2F;O控制方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">程序直接控制方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">中断驱动方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%98%E5%8F%96-DMA-Direct-Memory-Access-%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">直接存储器存取(DMA, Direct Memory Access)方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">通道控制方式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%EF%BC%9A\"><span class=\"toc-text\">对比：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-4-I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">8.4 I&#x2F;O软件层次结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B1%82%E6%AC%A1%E6%80%BB%E8%A7%88%EF%BC%9A\"><span class=\"toc-text\">层次总览：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%84%E5%B1%82%E6%AC%A1%E5%8A%9F%E8%83%BD%EF%BC%9A\"><span class=\"toc-text\">各层次功能：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-5-%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF-SPOOLing\"><span class=\"toc-text\">8.5 假脱机技术(SPOOLing)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-6-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">8.6 设备的分配与回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%97%B6%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">设备分配时应考虑的因素：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A\"><span class=\"toc-text\">设备分配管理中的数据结构：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">设备分配过程：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B%EF%BC%9A\"><span class=\"toc-text\">设备分配过程改进：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-7-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">8.7 缓冲区管理</span></a></li></ol></li></ol></li></ol>","author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"计算机网络学习笔记2","uid":"50324cd41e6545436b99690f3c71831f","slug":"计算机网络学习笔记2","date":"2023-07-29T11:46:57.000Z","updated":"2023-08-03T04:33:45.173Z","comments":true,"path":"api/articles/计算机网络学习笔记2.json","keywords":null,"cover":[],"text":"第四章 网络层4.1 网络层概述 网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输 网络层主要解决的问题： 网络层向运输层提供怎样的服务(“可靠传输”还是“不可靠传输”) 网络层寻址问题 路由选择问题 因特网(Internet)是全世界用户数量最多的互联网，它使用...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"}],"author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"操作系统学习笔记","uid":"495c8986559724f8c32aca1912ddb729","slug":"操作系统学习笔记","date":"2023-07-23T05:28:43.000Z","updated":"2023-07-30T05:46:22.731Z","comments":true,"path":"api/articles/操作系统学习笔记.json","keywords":null,"cover":[],"text":" 第一章 概述 1.1 操作系统的概念和功能： 是系统资源的管理者(管理整个计算机系统的硬件和软件资源) 向上层(用户和其他软件)提供接口和环境 最接近硬件的一层软件(硬件上的第一层软件，是对硬件系统的首次扩充) 1.2 操作系统的发展历程 1.3 操作系统的四大特征并发： 并发...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"操作系统","slug":"操作系统","count":2,"path":"api/tags/操作系统.json"}],"author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}