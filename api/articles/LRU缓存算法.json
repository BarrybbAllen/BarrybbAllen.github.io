{"title":"LRU缓存算法","uid":"3405a51be28fbdb1c58ecac6d40a5d4d","slug":"LRU缓存算法","date":"2023-07-04T07:30:07.000Z","updated":"2023-07-10T15:02:18.105Z","comments":true,"path":"api/articles/LRU缓存算法.json","keywords":null,"cover":null,"content":"<h1 id=\"LRU缓存\"><a href=\"#LRU缓存\" class=\"headerlink\" title=\"LRU缓存\"></a>LRU缓存</h1><hr>\n<p><em>最近在做6.830 Lab2时涉及到了实现BufferPool中的eviction policy，即页面置换算法，简单来说，PageId与Page的映射关系为HashMap&lt;PageId, LinkedNode&gt; bufferPool，LinkedNode是自定义双向链表节点，节点内保存了PageId和Page，以及前驱和后继节点prev、next。每当BufferPool中的Page被访问时，将该PageId对应的LinkedNode移动到链表的头部。同时当有Page需要放置到BufferPool中，且BufferPool的容量已经满时，则将最近最少使用的Page淘汰，即链表的最后一个节点，再将该Page放置到BufferPool中。</em></p>\n<p><em>这就是LRU(Last Recently Used, 最近最少使用)算法的思想，在实际的移动、删除和添加操作时，经常</em>引入虚<em>拟头结点和尾节点，使得在具体操作时,不必判断相邻节点是否存在。</em></p>\n<hr>\n<h3 id=\"一个最简单的LRU算法实现版本如下：\"><a href=\"#一个最简单的LRU算法实现版本如下：\" class=\"headerlink\" title=\"一个最简单的LRU算法实现版本如下：\"></a>一个最简单的LRU算法实现版本如下：</h3><p><a href=\"https://leetcode.cn/problems/lru-cache/\">LRU缓存</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class LRUCache &#123;\n    &#x2F;&#x2F; 定义一个双向链表\n    class DoubleLinedList&#123;\n        int key;\n        int value;\n        DoubleLinedList prev;\n        DoubleLinedList next;\n\n        public DoubleLinedList()&#123;&#125;\n\n        public DoubleLinedList(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n\n    private Map&lt;Integer, DoubleLinedList&gt; map &#x3D; new HashMap&lt;&gt;();\n\n    &#x2F;&#x2F; 虚拟头结点和尾节点\n    &#x2F;&#x2F; 使得在插入和删除节点操作时,不必判断相邻节点是否存在\n    private DoubleLinedList head, tail;\n    private int size;\n    private int capacity;\n\n    public LRUCache(int capacity) &#123;\n        &#x2F;&#x2F; initialize\n        this.capacity &#x3D; capacity;\n        this.size &#x3D; 0;\n        head &#x3D; new DoubleLinedList();\n        tail &#x3D; new DoubleLinedList();\n        head.next &#x3D; tail;\n        tail.prev &#x3D; head;\n    &#125;\n\n    public int get(int key) &#123;\n         DoubleLinedList node &#x3D; map.get(key);\n         &#x2F;&#x2F; 节点存在，需要移动到头部\n        if(node &#x3D;&#x3D; null)&#123;\n           return -1;\n        &#125;\n        movetoHead(node);\n        return node.value;\n    &#125;\n\n    public void put(int key, int value) &#123;\n        DoubleLinedList node &#x3D; map.get(key);\n        &#x2F;&#x2F; 节点存在，需要更新值，并移动到头部\n        if(node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            movetoHead(node);\n        &#125;\n        else&#123;\n            &#x2F;&#x2F; 创建节点\n            DoubleLinedList newNode &#x3D; new DoubleLinedList(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            size++;\n            &#x2F;&#x2F; 如果超出了容量，需要删除最久未使用的节点，就是虚拟伪节点的前一个节点\n            if(size &gt; capacity)&#123;\n                DoubleLinedList lastNode &#x3D; romoveLastUsed();\n                removeNode(lastNode);\n                map.remove(lastNode.key);\n                size--;\n            &#125;\n\n        &#125;\n\n    &#125;\n    &#x2F;&#x2F; 向头部插入节点\n    private void addToHead(DoubleLinedList node)&#123;\n        node.next &#x3D; head.next;\n        node.prev &#x3D; head;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n    &#125;\n\n    &#x2F;&#x2F; 删除节点,即直接跳过该节点\n    private void removeNode(DoubleLinedList node)&#123;\n        node.prev.next &#x3D; node.next;\n        node.next.prev &#x3D; node.prev;\n\n    &#125;\n\n    &#x2F;&#x2F; 将最近被使用的节点移动到头部,但是要先在原来的位置删除该节点\n    private void movetoHead(DoubleLinedList node)&#123;\n        removeNode(node);\n        addToHead(node);\n    &#125;\n\n    &#x2F;&#x2F; 返回最久未使用的节点,即虚拟节点的前一个节点\n    private DoubleLinedList romoveLastUsed()&#123;\n        DoubleLinedList cur &#x3D; tail.prev;\n        &#x2F;&#x2F; removeNode(cur);\n        return cur;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>Comment:</strong></p>\n<p><strong>时间复杂度：O(1)</strong></p>\n<p><strong>空间复杂度：O(n)</strong></p>\n","text":"LRU缓存 最近在做6.830 Lab2时涉及到了实现BufferPool中的eviction policy，即页面置换算法，简单来说，PageId与Page的映射关系为HashMap&lt;PageId, LinkedNode&gt; bufferPool，LinkedNode...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"project","slug":"project","count":1,"path":"api/tags/project.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#LRU%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">LRU缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">一个最简单的LRU算法实现版本如下：</span></a></li></ol></li></ol></li></ol>","author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Linux下Redis的使用","uid":"61cb2404786c8e041ac91f953c81aea7","slug":"Linux下Redis的使用","date":"2023-07-09T09:35:15.000Z","updated":"2023-07-10T15:00:59.620Z","comments":true,"path":"api/articles/Linux下Redis的使用.json","keywords":null,"cover":null,"text":"CentOS 7虚拟机下Redis的启动和使用常用命令如下（使用这些命令前要先配置系统服务文件）： 启动Redis： – systemctl start redis 查看Redis运行状态： – systemctl status redis 或 – ps -ef | grep r...","link":"","photos":[],"count_time":{"symbolsCount":511,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"study note","slug":"study-note","count":1,"path":"api/tags/study-note.json"}],"author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Leetcode417_水流问题","uid":"4f4fe6709de0267b7f3da59b044be8c2","slug":"Leetcode417-水流问题","date":"2022-12-18T01:44:54.000Z","updated":"2023-07-10T15:01:34.310Z","comments":true,"path":"api/articles/Leetcode417-水流问题.json","keywords":null,"cover":null,"text":"题目描述 Leetcode417-太平洋大西洋水流问题 有一个m x n的矩形岛屿，与 太平洋和大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。 这个岛被分割成一个由若干方形单元格组成的网格。给定一个m x n的整数矩阵*heigh...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","count":3,"path":"api/tags/Leetcode.json"}],"author":{"name":"Qin Zehao","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}